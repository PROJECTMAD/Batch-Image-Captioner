<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="app-version" content="1.0.1e">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Batch Image Captioner</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
<style>
    :root {
        /* --- Light Theme (Default) --- */
        /* Primary Palette (Teal-ish) */
        --primary-color: #26a69a;       /* Teal */
        --primary-color-light: #64d8cb;  /* Teal Lighten-2 (approx) */
        --primary-color-dark: #00796b;   /* Teal Darken-2 */
        --accent-color: #26a69a;         /* Accent color - can be same as primary */
        --link-color: var(--primary-color-dark);

        /* Backgrounds & Text */
        --body-bg: #f4f5f7;              /* Light grayish blue - softer than pure white */
        --text-color: #212121;           /* Dark Grey for text */
        --muted-text-color: #757575;     /* Medium Grey for muted text, placeholders */
        --border-color: #e0e0e0;         /* Light Grey for borders */

        /* Component Backgrounds */
        --card-bg: #ffffff;
        --sidenav-bg: #eceff1;           /* Blue Grey Lighten-5 */
        --input-bg: #ffffff;             /* Inputs on white background */
        --tabs-bg: var(--card-bg);       /* Tabs usually on card background */
        --console-bg: #fafafa;           /* Slightly off-white for console */
        
        /* Component Text & Borders */
        --card-title-color: var(--text-color);
        --card-border-color: var(--border-color);
        --sidenav-text-color: #37474f;   /* Blue Grey Darken-2 */
        --sidenav-border-color: #cfd8dc; /* Blue Grey Lighten-3 */
        --input-border-color: #9e9e9e;   /* Grey for input borders */
        --input-text-color: #424242;     /* Grey Darken-3 for input text */
        --input-label-color: var(--muted-text-color);
        --input-label-active-color: var(--accent-color);
        --console-border: var(--border-color);

        /* Buttons */
        --btn-bg: var(--primary-color);
        --btn-text-color: #ffffff;
        --btn-hover-bg: var(--primary-color-light);
        --btn-disabled-bg: #DFDFDF;      /* Light grey for disabled */
        --btn-disabled-text: #9F9F9F;    /* Darker grey text for disabled */

        /* Console Messages */
        --console-info-bg: #e3f2fd; --console-info-text: #0d47a1;
        --console-success-bg: #e8f5e9; --console-success-text: #1b5e20;
        --console-warning-bg: #fff3e0; --console-warning-text: #e65100;
        --console-error-bg: #ffebee; --console-error-text: #b71c1c;

        /* Queue Item Specifics */
        --queue-item-output-bg: #455a64; /* Darker for output box */
        --queue-item-output-text: #cfd8dc;
        --queue-item-thumbnail-border: #b0bec5;
        --queue-item-title-color: #263238;
        --queue-item-status-color: #546e7a;

        /* Tabs Specifics */
        --tabs-indicator-color: var(--accent-color);
        --tabs-link-active-color: var(--accent-color);
        --tabs-link-color: rgba(38, 166, 154, 0.7); /* Primary color, semi-transparent */

        /* Sizes (remain consistent) */
        --body-width: 1280px;
        --navbar-height: 64px;
        --sidenav-width: 650px; /* Default width for persistent sidenav */
        /* --main-width: 655px; Not strictly needed if main is flex-grow */
        /* --container-height: 765px; Not used directly, height is calc(100vh - navbar) */
    }

    body.dark-theme {
        /* --- Dark Theme --- */
        /* Primary Palette (Cool Blue) */
        --primary-color: #2196F3;       /* Materialize Blue */
        --primary-color-light: #64B5F6;  /* Materialize Blue Lighten-2 */
        --primary-color-dark: #1976D2;   /* Materialize Blue Darken-2 */
        --accent-color: var(--primary-color-light); /* Use lighter blue for accents */
        --link-color: var(--accent-color);

        /* Backgrounds & Text */
        --body-bg: #121212;              /* Very dark grey / true black */
        --text-color: #e0e0e0;           /* Light grey for primary text */
        --muted-text-color: #8e8e93;     /* Medium grey for muted text */
        --border-color: #38383a;         /* Subtle dark border */

        /* Component Backgrounds */
        --card-bg: #1e1e1e;              /* Dark grey for cards */
        --sidenav-bg: #171717;           /* Slightly different dark for sidenav */
        --input-bg: #2c2c2e;             /* Dark input background */
        --tabs-bg: var(--card-bg);
        --console-bg: var(--input-bg);   /* Console matching input bg */

        /* Component Text & Borders */
        --card-title-color: var(--text-color);
        --card-border-color: var(--border-color);
        --sidenav-text-color: var(--text-color);
        --sidenav-border-color: var(--border-color);
        --input-border-color: #545458;
        --input-text-color: var(--text-color);
        --input-label-color: var(--muted-text-color);
        --input-label-active-color: var(--accent-color);
        --console-border: var(--border-color);

        /* Buttons */
        --btn-bg: var(--primary-color);
        --btn-text-color: #ffffff;
        --btn-hover-bg: var(--primary-color-light);
        --btn-disabled-bg: #3a3a3c;
        --btn-disabled-text: #757575;

        /* Console Messages */
        --console-info-bg: #1a237e91; --console-info-text: #c5cae9;    /* Indigo dark */
        --console-success-bg: #1b5e2091; --console-success-text: #c8e6c9; /* Green dark */
        --console-warning-bg: #e6510091; --console-warning-text: #ffe0b2; /* Orange dark */
        --console-error-bg: #b71c1c91; --console-error-text: #ffcdd2;     /* Red dark */

        /* Queue Item Specifics */
        --queue-item-output-bg: #2c2c2e; /* Matching input bg */
        --queue-item-output-text: #c7c7cc;
        --queue-item-thumbnail-border: var(--border-color);
        --queue-item-title-color: var(--text-color);
        --queue-item-status-color: var(--muted-text-color);

        /* Tabs Specifics */
        --tabs-indicator-color: var(--accent-color);
        --tabs-link-active-color: var(--accent-color);
        --tabs-link-color: var(--muted-text-color); /* Inactive tabs in dark mode */
    }

    /* --- Global Styles --- */
    html {
        display: flex;
        box-sizing: border-box;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    }
    *, *:before, *:after {
        box-sizing: inherit;
    }

    body {
        background-color: var(--body-bg);
        color: var(--text-color);
        padding-top: var(--navbar-height);
        display: inherit;
        margin: 0 auto;
        max-width: var(--body-width);
        overflow: hidden;
        max-height: 100vh;
    }

    /* --- Blur Overlay --- */
    #pageBlurOverlay {
        position: fixed;
        top: 0; left: 0;
        width: 100vw; height: 100vh;
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        z-index: 1002; /* Below Materialize modal overlay */
        display: none; /* Controlled by JS */
        background-color: rgba(0,0,0,0.1); /* Optional: slight dim */
    }
    #pageBlurOverlay.active {
        display: block;
    }

    /* --- Navbar --- */
    nav {
        position: fixed;
        top: 0; left: 0;
        width: 100vw; /* Full viewport width */
        height: var(--navbar-height);
        z-index: 1000;
        background-color: var(--primary-color) !important; /* For Materialize override */
        color: var(--btn-text-color);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    body.dark-theme nav { /* Dark theme navbar style */
        background-color: var(--card-bg) !important;
        border-bottom: 1px solid var(--border-color);
        box-shadow: none;
    }
    nav .nav-wrapper {
        position: relative !important; /* Override Materialize for better control if needed */
        display: flex !important;
        align-items: center;
        height: 100%;
        padding: 0 1rem; /* Standard padding */
    }
    nav .brand-logo {
        position: absolute; /* For true centering */
        left: 50%;
        transform: translateX(-50%);
        color: var(--btn-text-color);
        font-size: 1.5rem;
    }
    body.dark-theme nav .brand-logo { color: var(--text-color); }
    nav .sidenav-trigger {
        color: var(--btn-text-color);
        margin-right: 10px; /* Space it from edge */
    }
    body.dark-theme nav .sidenav-trigger i,
    body.dark-theme nav ul.right a i {
        color: var(--accent-color); /* Icons use accent color in dark theme */
    }
    body.dark-theme nav ul.right a {
         color: var(--text-color); /* Ensure link text (if any) is also visible */
    }
    nav ul.right { /* For theme/settings icons */
        display: flex;
        align-items: center;
    }
    nav ul.right li a { padding: 0 12px; }


    /* --- Sidenav --- */
    #imageQueueSidenav {
        /* position: relative; No, Materialize needs fixed/absolute for overlay */
        width: var(--sidenav-width); /* Default width, JS might hide it or Materialize handles overlay */
        min-height: 528px;
        height: max-content;
        max-height: calc(100% - var(--navbar-height));
        background-color: var(--sidenav-bg);
        color: var(--sidenav-text-color);
        z-index: 999; /* Standard Materialize sidenav z-index for overlay */
        border-right: 1px solid var(--sidenav-border-color);
        overflow-y: auto;
        flex-shrink: 0; /* Prevent shrinking in flex context */
        box-shadow: 2px 0 5px rgba(0,0,0,0.05); /* Softer shadow */
        margin: 31.5px auto;

        /* For persistent state (controlled by adding this class via JS) */
        /* When persistent, it's not an overlay, so needs to be part of flex flow */
    }
    #imageQueueSidenav.sidenav-persistent {
        position: relative; /* Take it out of overlay flow */
        transform: translateX(0) !important; /* Ensure it's visible */
        z-index: 1; /* Lower z-index than main content if overlap occurs, but should be side-by-side */
    }
    /* Default Materialize sidenav is display:none and transformed until opened */


    /* --- Main Content Area --- */
    main {
        flex-grow: 1; /* Takes up remaining space */
        width: 100%;  /* Important for flex calculation if sidenav width varies */
        height: calc(100vh - var(--navbar-height));
        overflow-y: auto; /* Allows main content to scroll */
        background-color: var(--body-bg);
        padding: 0; /* Padding is on the inner container */
        /* NO margin-left manipulation */
    }
    #mainContentContainer {
        max-width: 700px; /* Max width for the content block */
        margin: 0 auto;   /* Centering the content block */
        padding: 24px 20px; /* Consistent padding */
    }

    /* --- Materialize Component Theming & Overrides --- */
    /* Cards */
    .card {
        background-color: var(--card-bg);
        color: var(--text-color);
        border: 1px solid var(--card-border-color);
        box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        border-radius: 6px; /* Standardized border radius */
        margin-bottom: 20px; /* Consistent spacing */
    }
    .card .card-content { padding: 20px; }
    .card .card-title {
        color: var(--card-title-color);
        font-size: 1.4rem;
        font-weight: 500;
        margin-bottom: 15px;
    }

    /* Tabs */
    .tabs {
        background-color: var(--tabs-bg);
        border-bottom: 1px solid var(--card-border-color); /* Match card border */
    }
    .tabs .tab a {
        color: var(--tabs-link-color);
        text-transform: none; /* Cleaner look */
        font-weight: 500;
    }
    .tabs .tab a:hover { color: var(--tabs-link-active-color); }
    .tabs .tab a.active { color: var(--tabs-link-active-color) !important; }
    .tabs .indicator { background-color: var(--tabs-indicator-color); }
    body.dark-theme .tabs { border-bottom-color: var(--border-color); }

    /* Input Fields (general styling for Materialize) */
    .input-field .helper-text {
        color: var(--input-text-color);
    }
    .input-field label { color: var(--input-label-color); }
    .input-field input[type=text]:not(.browser-default),
    .input-field input[type=url]:not(.browser-default),
    .input-field input[type=password]:not(.browser-default),
    .input-field textarea:not(.browser-default) {
        background-color: transparent; /* Let card/page bg show through */
        border-bottom: 1px solid var(--input-border-color);
        border-radius: 0; /* Materialize default */
        color: var(--input-text-color);
        padding: 0.5rem 0; /* Adjust padding for better vertical alignment */
    }
    .input-field input[type=text]:not(.browser-default):focus:not([readonly]),
    .input-field input[type=url]:not(.browser-default):focus:not([readonly]),
    .input-field input[type=password]:not(.browser-default):focus:not([readonly]),
    .input-field textarea:not(.browser-default):focus:not([readonly]) {
        border-bottom: 1px solid var(--accent-color);
        box-shadow: 0 1px 0 0 var(--accent-color);
    }
    .input-field label.active { color: var(--accent-color); }
    .file-field .file-path.validate {
        color: var(--input-text-color);
        border-bottom: 1px solid var(--input-border-color);
    }
    .file-field .file-path-wrapper { padding-left: 10px; }
    .file-field .btn, .file-field .btn:hover {
        background-color: var(--btn-bg);
        color: var(--btn-text-color);
    }
    body.dark-theme .file-field .btn, 
    body.dark-theme .file-field .btn:hover { background-color: var(--btn-bg); }


    /* Radio Buttons */
    [type="radio"]:not(:checked)+span:before,
    [type="radio"]:not(:checked)+span:after {
        border: 2px solid var(--input-border-color); /* Match input border for consistency */
    }
    [type="radio"]:checked+span:after,
    [type="radio"].with-gap:checked+span:before,
    [type="radio"].with-gap:checked+span:after {
        border: 2px solid var(--accent-color);
    }
    [type="radio"]:checked+span:after { background-color: var(--accent-color); }
    form p label span { color: var(--text-color); } /* Label text color */

    /* Buttons */
    .btn, .btn-floating, .btn-large {
        background-color: #78909c;
        color: var(--btn-text-color);
        text-transform: none; /* Cleaner buttons */
        font-weight: 500;
        border-radius: 4px; /* Slightly less rounded */
    }
    .btn:hover, .btn-floating:hover, .btn-large:hover { background-color: var(--btn-hover-bg); }
    .btn.red, .btn-floating.red { background-color: #f44336 !important; } /* Materialize red */
    .btn.red:hover, .btn-floating.red:hover { background-color: #e53935 !important; }
    body.dark-theme .btn.red, body.dark-theme .btn-floating.red { background-color: #ef5350 !important; } /* Lighter red for dark */
    body.dark-theme .btn.red:hover, body.dark-theme .btn-floating.red:hover { background-color: #e57373 !important; }
    .btn:disabled i, .btn-large:disabled i { /* Ensure icon color also changes */
        color: var(--btn-disabled-text) !important;
    }
    .btn:disabled, .btn-large:disabled, .btn-floating:disabled {
        background-color: var(--btn-disabled-bg) !important;
        color: var(--btn-disabled-text) !important;
        cursor: not-allowed;
        box-shadow: none !important;
    }
    .btn-large {
        padding: 0 12px;
    }
    body.dark-theme .btn:disabled, body.dark-theme .btn-large:disabled, body.dark-theme .btn-floating:disabled {
        background-color: var(--btn-disabled-bg) !important;
        color: var(--btn-disabled-text) !important;
        cursor: not-allowed;
        box-shadow: none !important;
        opacity: 0.65;
    }

    /* Tabs */
    .tabs .tab a:focus,
    .tabs .tab a:focus.active {
        background-color: transparent !important;
        outline: none !important;
    }
    .tabs .tab a:hover,
    .tabs .tab a.active {
        background-color: transparent !important;
    }

    /* Paste Area */
    #pasteArea {
        border: 2px dashed var(--muted-text-color); padding: 20px; text-align: center;
        cursor: pointer; min-height: 100px; display: flex;
        align-items: center; justify-content: center; margin-top: 10px;
        background-color: var(--input-bg); /* Use input background or a distinct one */
        border-radius: 4px;
    }
    body.dark-theme #pasteArea { background-color: rgba(0,0,0,0.1); /* Slightly transparent on dark */ }


    /* Loader */
    .loader-container { display: none; text-align: center; margin-top: 20px; }
    .loader-container.active { display: flex; align-items:center; justify-content:center; flex-direction:column; }
    .material-icons.spin { animation: spin 1.5s linear infinite; line-height: inherit; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* --- Dropdown --- */
    .dropdown-content {
        background-color: var(--input-bg) !important;
    }
    .dropdown-content li > a, .dropdown-content li > span {
        color: var(--input-text-color) !important;
    }

    /* --- Sidenav Queue Item Styling --- */
    #imageQueueSidenav .subheader {
        font-weight: 500; padding: 0 16px; line-height:48px;
        color: var(--sidenav-text-color);
        border-bottom: 1px solid var(--sidenav-border-color);
    }
    #imageQueueSidenav .subheader > div:last-child {
        pointer-events: auto;
    }
    #imageQueueSidenav .subheader .dropdown-trigger:not(.disabled):not([disabled]) {
        pointer-events: auto;
        cursor: pointer;
    }
    #imageQueueSidenav .subheader .dropdown-trigger.disabled,
    #imageQueueSidenav .subheader .dropdown-trigger[disabled] {
        background-color: var(--btn-disabled-bg) !important;
        color: var(--btn-disabled-text) !important;
        cursor: not-allowed !important;
        pointer-events: none !important;
        opacity: 0.65;
    }
    #imageQueueSidenav .divider { margin: 0; background-color: var(--sidenav-border-color); } /* Thinner divider */
    #emptyQueueMessageSidenav { padding: 16px; color: var(--muted-text-color); text-align: center; }

    .queue-item {
        display: flex; align-items: center; padding: 12px 16px;
        border-bottom: 1px solid var(--sidenav-border-color);
    }
    .queue-item:last-child { border-bottom: none; }
    .queue-item-thumbnail {
        width: 100px; height: auto; aspect-ratio: 832 / 1216; /* Maintain aspect ratio */
        object-fit: cover; margin-right: 12px;
        border-radius: 4px; border: 1px solid var(--queue-item-thumbnail-border);
        flex-shrink: 0;
    }
    .queue-item-details { flex-grow: 1; min-width: 0; /* For text overflow */ }
    .queue-item-title {
        font-weight: 500; display: block; margin-bottom: 4px;
        color: var(--queue-item-title-color);
        white-space: nowrap; overflow: hidden; text-overflow: ellipsis; /* Prevent long names breaking layout */
    }
    .queue-item-status {
        font-style: italic; color: var(--queue-item-status-color);
        margin-bottom: 4px; font-size: 0.85em;; font-weight: bold;
    }
    .queue-item-status.processing { color: var(--accent-color); } /* Use accent for processing */
    .queue-item-status.completed { color: var(--btn-bg); }
    .queue-item-status.error { color: var(--error-color); }
    .queue-item-output {
        background-color: var(--queue-item-output-bg);
        color: var(--queue-item-output-text);
        padding: 8px 10px; border-radius: 4px;
        overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;
        font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; /* Better mono stack */
        font-size: 0.8em; max-height: 90px; margin-top: 5px;
        border: 1px solid var(--border-color); /* Subtle border for output box */
    }
    .queue-item-actions {
        display: flex;
        margin-right: 8px;
        position: absolute;
        margin-bottom: 85px;
        right: 5px;
    }
    .queue-item-actions .btn-floating {
        margin-bottom: 5px;
        width: 32px; height: 32px; line-height: 32px;
    }
    .queue-item-actions .btn-floating i { font-size: 1.2rem; line-height: 32px; }
    .queue-item-actions .btn-floating:last-child { margin-bottom: 0; }
    .btn-floating.copied { background-color: var(--btn-bg) !important; }
    .btn-floating.copied .material-icons { color: var(--btn-text-color) !important; }
    /* body.dark-theme .btn-floating.copied { background-color: var(--console-success-color) !important; }
    body.dark-theme .btn-floating.copied .material-icons { color: white !important; } */

    /* --- Console Log Area --- */
    #consoleLog { margin-top: 20px; } /* Already a card, inherits card styles */
    #consoleMessages { 
        max-height: 180px; /* Slightly taller */
        overflow-y: auto; 
        font-size: 0.85em; 
        background-color: var(--console-bg); 
        padding: 10px;
        border-radius: 4px; /* Inner radius */
        border: 1px solid var(--console-border);
    }
    #consoleMessages p { margin: 2px 0; padding: 4px 6px; border-radius: 3px; line-height: 1.4; }
    #consoleMessages p .timestamp { font-size: 0.85em; color: var(--muted-text-color); margin-right: 6px;}
    #consoleMessages p .duration { font-style: italic; color: var(--primary-color-dark); margin-left: 6px; }
    body.dark-theme #consoleMessages p .duration { color: var(--primary-color-light); }

    #consoleMessages p.console-info { background-color: var(--console-info-bg); color: var(--console-info-text);}
    #consoleMessages p.console-success { background-color: var(--console-success-bg); color: var(--console-success-text);}
    #consoleMessages p.console-warning { background-color: var(--console-warning-bg); color: var(--console-warning-text);}
    #consoleMessages p.console-error { background-color: var(--console-error-bg); color: var(--console-error-text);}

    /* --- Settings Modal --- */
    /* Materialize modal z-index adjustments if needed, handled by !important if necessary */
    .modal {
        background-color: var(--card-bg);
        color: var(--text-color);
        border-radius: 6px;
        max-height: 800px !important;
        max-width: 1280px !important;
        margin: auto;
        overflow-y: hidden;
        user-select: none;
        -ms-user-select: none;
        -moz-user-select: none;
        -webkit-user-select: none;
    }
    .modal .modal-content { padding: 24px; }
    .modal .modal-footer {
        background-color: var(--card-bg);
        border-top: 1px solid var(--card-border-color);
        padding: 8px 24px; /* Adjust padding */
    }
    .modal.modal-fixed-footer {
        padding: 0;
        height: 80vh;
        width: 80vw;
    }
    .modal .modal-footer .btn-flat {
        color: var(--accent-color);
        font-weight: 500;
    }
    body.dark-theme .modal { border: 1px solid var(--border-color); }
    body.dark-theme .modal .modal-footer { border-top-color: var(--border-color); }
    
    /* Materialize Tooltip Theming */
    .material-tooltip {
        padding: 0;
        background-color: transparent;
        border-radius: 0;
    }

    .material-tooltip .tooltip-content {
        background-color: #323232;
        color: #fff;
        font-size: 0.9rem;
        padding: 6px 10px;
        border-radius: 2px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
    }
    body.dark-theme .material-tooltip .tooltip-content {
        background-color: #424242;
        color: #e0e0e0;
    }

</style>
</head>
<body>
    <div id="pageBlurOverlay"></div>

    <header>
        <nav> <!-- Color from CSS var -->
            <div class="nav-wrapper">
                <a href="#" data-target="imageQueueSidenav" class="sidenav-trigger"><i class="material-icons">menu</i></a>
                <a href="#" class="brand-logo center"></a>
                <ul class="right">
                    <li><a href="#!" id="themeToggle" title="Toggle Theme"><i class="material-icons">brightness_4</i></a></li>
                    <li><a href="#settingsModal" class="modal-trigger" title="Settings"><i class="material-icons">settings</i></a></li>
                </ul>
            </div>
        </nav>
    </header>

    <main>
        <div id="mainContentContainer">
            <!-- Input Controls Cards -->
            <div class="card">
                <div class="card-content">
                    <span class="card-title">1. Load Image(s)</span>
                     <div class="row" style="margin-bottom: 0;"> <!-- Remove default row margin -->
                        <div class="col s12">
                            <ul class="tabs">
                                <li class="tab col s4"><a class="active" href="#uploadTab">Upload</a></li>
                                <li class="tab col s4"><a href="#urlTab">From URL</a></li>
                                <li class="tab col s4"><a href="#pasteTab">Paste</a></li>
                            </ul>
                        </div>
                        <div id="uploadTab" class="col s12" style="padding-top: 20px;">
                            <div class="file-field input-field">
                                <div class="btn" style="margin-top:12px;"><span>Files</span><input type="file" id="imageUpload" accept="image/*" multiple></div>
                                <div class="file-path-wrapper"><input class="file-path validate" type="text" placeholder="Upload one or more images"></div>
                            </div>
                        </div>
                        <div id="urlTab" class="col s12" style="padding-top: 20px;">
                            <div class="input-field">
                                <input id="imageUrlInput" type="text" class="validate"><label for="imageUrlInput">Image URL (CORS Permitting)</label>
                            </div>
                            <button class="btn waves-effect waves-light" id="addImageFromUrlButton" style="width:100%;">Add from URL</button>
                            <p class="caption grey-text" style="font-size:0.8rem; margin-top:5px;">Note: Loading from URL may fail due to CORS.</p>
                        </div>
                        <div id="pasteTab" class="col s12" style="padding-top: 20px;">
                            <div id="pasteArea" contenteditable="false">Click or Paste Image Here</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-content">
                    <span class="card-title">2. Choose Prompt</span>
                    <form id="promptForm">
                        <p><label><input name="promptType" type="radio" value="sd" checked /><span>Stable Diffusion Prompt</span></label></p>
                        <p><label><input name="promptType" type="radio" value="danbooru" /><span>Danbooru Tags</span></label></p>
                    </form>
                </div>
            </div>

            <button class="btn waves-effect waves-light btn-large" id="processQueueButton" style="width:100%; margin-top:10px;" disabled>
                Process Queue <i class="material-icons right">playlist_play</i>
            </button>
            <button class="btn waves-effect waves-light red" id="clearQueueButton" style="width:100%; margin-top:10px;" disabled>
                Clear Queue <i class="material-icons right">clear_all</i>
            </button>

            <!-- Console Log Area -->
            <div id="consoleLog" class="card" style="display: none;"> <!-- Initially hidden -->
                <div class="card-content" style="padding-bottom: 10px;">
                    <span class="card-title" style="font-size: 1.2rem; margin-bottom: 10px;">Console</span>
                    <div id="consoleMessages">
                        <!-- Messages will be prepended here -->
                    </div>
                </div>
            </div>
        </div>
    </main>

    <ul id="imageQueueSidenav" class="sidenav"> <!-- Materialize 'sidenav' class for JS control -->
        <li>
            <div class="subheader" style="display: flex; justify-content: space-between; align-items: center; padding-right: 8px;">
                <span>Image Queue (<span id="queueCountSidenav">0</span>)</span>
                <div>
                    <a class="waves-effect waves-light btn-small tooltipped dropdown-trigger blue-grey lighten-1" href="#!" data-target="copyOptionsDropdown" id="copyAllOutputsButton" data-position="bottom" data-tooltip="Copy All Outputs" disabled><i class="material-icons left" style="margin-right: 4px;">content_copy</i>Copy</a>
                    <ul id="copyOptionsDropdown" class="dropdown-content">
                        <li><a href="#!" data-format="raw">RAW</a></li>
                        <li><a href="#!" data-format="json">JSON</a></li>
                    </ul>
                    <a class="waves-effect waves-light btn-small tooltipped dropdown-trigger blue-grey lighten-1" href="#!" data-target="downloadOptionsDropdown" id="downloadAllOutputsButton" data-position="left" data-tooltip="Download All Outputs" style="margin-left: 5px;" disabled><i class="material-icons left" style="margin-right: 4px;">file_download</i>Download</a>
                    <ul id="downloadOptionsDropdown" class="dropdown-content">
                        <li><a href="#!" data-format="raw">RAW</a></li>
                        <li><a href="#!" data-format="json">JSON</a></li>
                    </ul>
                </div>
            </div>
        </li>
        <li><div class="divider"></div></li>
        <div id="imageQueueAreaSidenav">
            <p id="emptyQueueMessageSidenav">Load images to see them here.</p>
        </div>
    </ul>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal modal-fixed-footer"> <!-- Added modal-fixed-footer for potentially taller content -->
        <div class="modal-content" style="padding-bottom: 10px;"> <!-- Adjusted padding -->
            <h4 id="settingsModalTitle" style="margin-bottom: 20px;">Settings</h4> <!-- More general title -->

            <div class="row" style="margin-bottom: 0;">
                <!-- Column 1: API Settings -->
                <div class="col s12 m6">
                    <h5>API Configuration</h5>
                    <p class="caption" style="margin-top:-10px; margin-bottom:15px;">Server, paths, model, and API Key.</p>
                    <div class="input-field">
                        <input id="apiBaseUrlInput" type="url" value="http://localhost:6969">
                        <label for="apiBaseUrlInput">Base Server URL</label>
                    </div>
                    <div class="input-field">
                        <input id="apiChatPathInput" type="text" value="/v1/chat/completions">
                        <label for="apiChatPathInput">Chat Completion Path</label>
                    </div>
                    <div class="input-field">
                        <select id="apiModelSelect">
                            <option value="" disabled selected>Loading models...</option>
                            <!-- Models will be populated here by JS -->
                        </select>
                        <label for="apiModelSelect">Model</label>
                    </div>
                    <div class="input-field">
                        <input id="apiKeyInput" type="password">
                        <label for="apiKeyInput">API Key (Optional)</label>
                    </div>
                    <p id="apiConnectionStatus" class="caption" style="min-height: 2.4em; margin-top:10px; font-weight: 500;"></p> <!-- Increased min-height for two lines -->
                </div>

                <!-- Column 2: Output Format Settings -->
                <div class="col s12 m6">
                    <h5>Output Formatting</h5>
                    <p class="caption" style="margin-top:-10px; margin-bottom:15px;">Customize "Copy/Download All" formats.</p>

                    <div class="input-field">
                        <input id="rawOutputDelimiterInput" type="text" value="\n\n">
                        <label for="rawOutputDelimiterInput">RAW Output Delimiter</label>
                        <span class="helper-text">Use '\n' for newline, '\t' for tab. Current default: two newlines.</span>
                    </div>

                    <div class="input-field" style="margin-top: 20px;">
                        <textarea id="jsonOutputSchemaInput" class="materialize-textarea" style="min-height: 180px; font-family: 'SFMono-Regular', Consolas, Menlo, monospace; font-size: 0.9em;"></textarea>
                        <label for="jsonOutputSchemaInput">JSON Output Schema Template</label>
                        <span class="helper-text">
                            Available Placeholders:<br>
                            `{{timestamp}}` - ISO date string of export time.<br>
                            `{{prompt_type}}` - The prompt type selected at export (e.g., "sd", "danbooru").<br>
                            `{{outputs_map_indexed}}` - Comma-separated key-values like "1":"output1", "2":"output2".<br>
                            `{{outputs_map_titled}}` - Comma-separated key-values like "ImgName1":"output1".<br>
                            `{{outputs_array_detailed}}` - Comma-separated JSON objects like {"index":1, "output":"out1", "displayTitle":"Title1"}.
                        </span>
                    </div>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="waves-effect waves-green btn-flat" id="saveApiSettingsButton">Save All Settings</button>
            <button class="waves-effect waves-blue btn-flat" id="testApiSettingsButton">Test API Only</button>
            <button class="modal-close waves-effect waves-grey btn-flat" id="closeApiSettingsButton" style="display:none;">Close</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <script>
        const APP_TITLE = document.querySelector('title').textContent;
        const APP_VERSION = document.querySelector('meta[name="app-version"]').getAttribute('content');
        document.querySelector('nav .brand-logo.center').textContent = `${APP_TITLE} v${APP_VERSION}`;

        const BASE_SERVER_URL_KEY = 'BiCaption_baseServerUrl';
        const CHAT_COMPLETION_PATH_KEY = 'BiCaption_chatCompletionPath';
        const SELECTED_MODEL_KEY = 'BiCaption_selectedModel';
        const API_KEY_KEY = 'BiCaption_apiKey';
        const THEME_KEY = 'BiCaption_theme';
        const SIDENAV_PERSISTENT_KEY = 'BiCaption_sidenavPersistent';
        const RAW_DELIMITER_KEY = 'BiCaption_rawOutputDelimiter';
        const JSON_SCHEMA_KEY = 'BiCaption_jsonOutputSchema';
        const DEFAULT_JSON_SCHEMA = `{
    "app_name": "${APP_TITLE}",
    "app_version": "${APP_VERSION}",
    "prompt_type_used": "{{prompt_type}}",
    "export_timestamp": "{{timestamp}}",
    "caption_data_indexed": {
        {{outputs_map_indexed}}
    }
}`;


        document.addEventListener('DOMContentLoaded', function() {
            // Initialize Materialize Components
            M.Tabs.init(document.querySelector('.tabs'));
            M.Tooltip.init(document.querySelectorAll('.tooltipped'));
            M.FormSelect.init(document.getElementById('apiModelSelect'));
            M.Dropdown.init(document.querySelectorAll('.dropdown-trigger'), {
                constrainWidth: false, // Allows dropdown to be wider than button
                coverTrigger: false // Dropdown appears below trigger
            });

            const sidenavElem = document.getElementById('imageQueueSidenav');
            const sidenavInstance = M.Sidenav.init(sidenavElem); // Initialize Materialize Sidenav
            const sidenavTrigger = document.querySelector('.sidenav-trigger');
            const pageBlurOverlay = document.getElementById('pageBlurOverlay');
            
            let isSidenavPersistent = localStorage.getItem(SIDENAV_PERSISTENT_KEY) === 'true';
            if (window.innerWidth < 993) { // Override for small screens
                isSidenavPersistent = false;
            }

            // --- API Settings Modal ---
            const settingsModalElement = document.getElementById('settingsModal');
            const settingsModalInstance = M.Modal.init(settingsModalElement, {
                onOpenEnd: () => {
                    rawOutputDelimiterInput.value = currentRawDelimiter;
                    jsonOutputSchemaInput.value = currentJsonSchema;

                    M.textareaAutoResize(jsonOutputSchemaInput);
                    M.updateTextFields();

                    if (settingsModalInstance.options.dismissible === false) {
                        setTimeout(() => { if (document.activeElement !== apiBaseUrlInput) apiBaseUrlInput.focus(); }, 100);
                    }
                }
            });
            const apiBaseUrlInput = document.getElementById('apiBaseUrlInput');
            const apiChatPathInput = document.getElementById('apiChatPathInput');
            const apiModelSelect = document.getElementById('apiModelSelect');
            const apiKeyInput = document.getElementById('apiKeyInput');
            const saveApiSettingsButton = document.getElementById('saveApiSettingsButton');
            const testApiSettingsButton = document.getElementById('testApiSettingsButton');
            const closeApiSettingsButton = document.getElementById('closeApiSettingsButton');
            const apiConnectionStatus = document.getElementById('apiConnectionStatus');
            const settingsModalTitle = document.getElementById('settingsModalTitle');
            const rawOutputDelimiterInput = document.getElementById('rawOutputDelimiterInput');
            const jsonOutputSchemaInput = document.getElementById('jsonOutputSchemaInput');

            let currentBaseUrl = localStorage.getItem(BASE_SERVER_URL_KEY) || 'http://localhost:6969';
            let currentChatPath = localStorage.getItem(CHAT_COMPLETION_PATH_KEY) || '/v1/chat/completions';
            let currentSelectedModel = localStorage.getItem(SELECTED_MODEL_KEY) || 'llama-joycaption-beta-one-hf-llava-mmproj';
            let currentApiKey = localStorage.getItem(API_KEY_KEY) || null;
            let availableModels = []; // To store fetched models
            let currentRawDelimiter = localStorage.getItem(RAW_DELIMITER_KEY) || '\\n\\n';
            let currentJsonSchema = localStorage.getItem(JSON_SCHEMA_KEY) || DEFAULT_JSON_SCHEMA;


            // --- Theme Switcher ---
            const themeToggle = document.getElementById('themeToggle');
            const themeIcon = themeToggle.querySelector('i');

            function applyTheme(theme) {
                if (theme === 'dark') {
                    document.body.classList.add('dark-theme');
                    themeIcon.textContent = 'brightness_7'; 
                } else {
                    document.body.classList.remove('dark-theme');
                    themeIcon.textContent = 'brightness_4';
                }
                 // Re-initialize tooltips if their appearance changes with theme
                M.Tooltip.init(document.querySelectorAll('.tooltipped'));
            }

            themeToggle.addEventListener('click', () => {
                const isDark = document.body.classList.contains('dark-theme');
                const newTheme = isDark ? 'light' : 'dark';
                localStorage.setItem(THEME_KEY, newTheme);
                applyTheme(newTheme);
            });
            applyTheme(localStorage.getItem(THEME_KEY) || 'light'); // Default to light


            // --- Core App Variables (Queue, Processing State) ---
            const copyAllOutputsButton = document.getElementById('copyAllOutputsButton');
            const downloadAllOutputsButton = document.getElementById('downloadAllOutputsButton');
            const imageUploadInput = document.getElementById('imageUpload');
            const imageUrlInput = document.getElementById('imageUrlInput');
            const addImageFromUrlButton = document.getElementById('addImageFromUrlButton');
            const pasteArea = document.getElementById('pasteArea');
            const promptForm = document.getElementById('promptForm');
            const processQueueButton = document.getElementById('processQueueButton');
            const clearQueueButton = document.getElementById('clearQueueButton');
            
            const imageQueueAreaSidenav = document.getElementById('imageQueueAreaSidenav');
            const emptyQueueMessageSidenav = document.getElementById('emptyQueueMessageSidenav');
            const queueCountSidenavSpan = document.getElementById('queueCountSidenav');

            const consoleLogDiv = document.getElementById('consoleLog');
            const consoleMessagesDiv = document.getElementById('consoleMessages');
            const MAX_CONSOLE_MESSAGES = 50;

            let imageQueue = [];
            let isProcessing = false;
            let isSingleItemProcessing = false;

            const NAME_PART_ADJECTIVES = ["Absurd", "Ancient", "Angry", "Awesome", "Awkward", "Bad", "Bald", "Big", "Bitter", "Blazing", "Blessed", "Blind", "Blue", "Bold", "Brave", "Brief", "Bright", "Broken", "Bumpy", "Calm", "Captain", "Charming", "Cheap", "Cheeky", "Clean", "Clumsy", "Cold", "Cool", "Cosmic", "Crazy", "Creepy", "Cruel", "Crying", "Cunning", "Curious", "Dapper", "Dark", "Deadly", "Deep", "Defiant", "Depressed", "Digital", "Dizzy", "Doctor", "Double", "Dramatic", "Dreamy", "Drunk", "Dusty", "Eager", "Early", "Easy", "Elder", "Electric", "Empty", "Evil", "Fake", "Fancy", "Fast", "Fat", "Final", "Flying", "Focused", "Forgotten", "Foxy", "Freezing", "Fresh", "Friendly", "Frozen", "Furious", "Fuzzy", "Gentle", "Ghost", "Giant", "Giga", "Gloomy", "Golden", "Good", "Grand", "Greedy", "Grim", "Grumpy", "Hairy", "Happy", "Haunted", "Heavy", "Hidden", "High", "Holy", "Honest", "Humble", "Hungry", "Hyper", "Icy", "Ideal", "Imperial", "Inner", "Iron", "Jolly", "Joyful", "Jumping", "Junior", "Keen", "Kind", "King", "Lazy", "Light", "Little", "Lone", "Long", "Lost", "Loud", "Lovely", "Lucky", "Mad", "Magic", "Major", "Mega", "Metal", "Mighty", "Mini", "Misty", "Modern", "Mutant", "Mystic", "Naked", "Nasty", "Naughty", "Nerdy", "New", "Noble", "Noisy", "Nuclear", "Odd", "Old", "Omega", "Only", "Orange", "Ordinary", "Outer", "Perfect", "Plain", "Plastic", "Polite", "Poor", "Powerful", "Pretty", "Prickly", "Prime", "Private", "Professor", "Proud", "Psycho", "Punchy", "Pure", "Purple", "Quick", "Quiet", "Rad", "Random", "Rapid", "Rebel", "Red", "Rich", "Risky", "Rock", "Rough", "Royal", "Rude", "Rusty", "Sad", "Salty", "Savage", "Scared", "Secret", "Serious", "Shadow", "Sharp", "Shiny", "Short", "Shy", "Silent", "Silly", "Silver", "Simple", "Sir", "Sleepy", "Slow", "Small", "Smart", "Smooth", "Sneaky", "Solid", "Sour", "Sparkly", "Special", "Spicy", "Spooky", "Steel", "Storm", "Strange", "Street", "Strong", "Stupid", "Super", "Sweet", "Swift", "Tall", "Ten", "Thin", "Thirsty", "Thunder", "Tiny", "Tired", "Top", "Total", "Tough", "Toxic", "True", "Twin", "Ultra", "Unholy", "Vain", "Vast", "Violent", "Void", "Wacky", "Warm", "Weak", "Weird", "Wet", "White", "Wicked", "Wide", "Wild", "Wise", "Wooden", "Young", "Yummy", "Zany", "Zombie", "Plump", "Leprechaun", "Depression", "Hooray"];
            const NAME_PART_NOUNS = ["Aardvark", "Abyss", "Agent", "Alien", "Alpaca", "Anarchy", "Angel", "Ant", "Anthem", "Anvil", "Apex", "Apple", "Archive", "Arena", "Armor", "Arrow", "Art", "Ash", "Attack", "Atom", "Aura", "Aurora", "Autumn", "Axe", "Bacon", "Badge", "Badger", "Baguette", "Banshee", "Baron", "Basilisk", "Bastion", "Bat", "Beacon", "Beard", "Beast", "Beauty", "Bed", "Bee", "Beer", "Beetle", "Bell", "Biscuit", "Blade", "Blast", "Blaze", "Blimp", "Bliss", "Blizzard", "Blob", "Block", "Blood", "Boar", "Boat", "Bomb", "Bone", "Bongo", "Book", "Boom", "Boot", "Boss", "Bottle", "Boulder", "Brain", "Branch", "Bread", "Breath", "Brick", "Bride", "Bridge", "Broccoli", "Bubble", "Bucket", "Buffalo", "Bug", "Bullet", "Bumble", "Bunker", "Burger", "Butter", "Button", "Cactus", "Cake", "Camel", "Candle", "Candy", "Cannon", "Canyon", "Cape", "Car", "Carpet", "Carrot", "Cash", "Castle", "Cat", "Cave", "Cell", "Centaur", "Chain", "Chair", "Chaos", "Charm", "Cheese", "Cherry", "Chicken", "Chief", "Child", "Chimera", "Chip", "Choir", "Chorus", "Cigar", "Cipher", "Circus", "Citizen", "Clam", "Claw", "Clay", "Clock", "Cloud", "Clown", "Cobra", "Code", "Coffee", "Coin", "Comet", "Cookie", "Copper", "Core", "Cosmos", "Couch", "Cow", "Coyote", "Crab", "Craft", "Crane", "Crash", "Crawler", "Cream", "Cricket", "Crime", "Crisis", "Crook", "Crow", "Crown", "Crux", "Crystal", "Cube", "Cult", "Cup", "Curse", "Cyborg", "Cyclone", "Czar", "Daemon", "Dagger", "Dance", "Dawn", "Day", "Death", "Decay", "Deer", "Demon", "Desert", "Design", "Desire", "Destiny", "Devil", "Dew", "Diamond", "Dice", "Digger", "Dilemma", "Dinosaur", "Disco", "Disease", "Disk", "Djinn", "Dock", "Dog", "Doll", "Dolphin", "Donkey", "Donut", "Doom", "Door", "Dragon", "Drake", "Dream", "Drill", "Drink", "Drone", "Drop", "Drug", "Drum", "Duck", "Duke", "Dune", "Dungeon", "Dust", "Dynamo", "Eagle", "Earth", "Echo", "Eclipse", "Eel", "Egg", "Ego", "Elf", "Elixir", "Ember", "Emblem", "Emperor", "Empire", "Engine", "Enigma", "Entity", "Epoch", "Error", "Essence", "Evening", "Event", "Exile", "Eye", "Fabric", "Face", "Fairy", "Falcon", "Fall", "Famine", "Fang", "Fantasy", "Farm", "Fate", "Father", "Fault", "Fear", "Feast", "Feather", "Fever", "Field", "Fiend", "Fig", "Fight", "Figure", "File", "Finger", "Fire", "Fish", "Fist", "Flag", "Flame", "Flask", "Flea", "Flesh", "Flint", "Flood", "Floor", "Flower", "Flute", "Flux", "Fly", "Foam", "Fog", "Folk", "Food", "Fool", "Foot", "Force", "Forest", "Forge", "Fork", "Form", "Fort", "Fossil", "Fox", "Fragment", "Frenzy", "Friend", "Frog", "Frost", "Fruit", "Fungus", "Fury", "Gadget", "Galaxy", "Gambit", "Game", "Gang", "Garden", "Garlic", "Gas", "Gate", "Gauntlet", "Gear", "Gecko", "Gem", "Genesis", "Genie", "Genius", "Ghost", "Ghoul", "Giant", "Gift", "Glacier", "Glade", "Glass", "Glaze", "Glitch", "Globe", "Gloom", "Glove", "Glow", "Glue", "Gnome", "Goat", "Goblin", "God", "Gold", "Golem", "Goose", "Gorge", "Gospel", "Grain", "Grape", "Grass", "Grave", "Greed", "Griffin", "Grimoire", "Grog", "Groom", "Grove", "Guard", "Guest", "Guide", "Guilt", "Guitar", "Gun", "Guru", "Gut", "Gym", "Gypsy", "Hacker", "Hail", "Hair", "Ham", "Hammer", "Hand", "Harbor", "Harmony", "Harp", "Harpy", "Hat", "Hate", "Hawk", "Haze", "Head", "Health", "Heart", "Heat", "Heaven", "Hedge", "Hell", "Helmet", "Herb", "Hermit", "Hero", "Hex", "Hive", "Hog", "Hole", "Holiday", "Home", "Honey", "Hood", "Hoof", "Hook", "Hope", "Horn", "Hornet", "Horror", "Horse", "Host", "Hound", "House", "Hulk", "Humor", "Hunt", "Hurricane", "Husk", "Hydra", "Hymn", "Ice", "Icon", "Idea", "Idol", "Illusion", "Image", "Impact", "Impulse", "Incense", "Inferno", "Ink", "Inn", "Insect", "Iron", "Island", "Issue", "Ivory", "Jackal", "Jacket", "Jade", "Jail", "Jam", "Jester", "Jet", "Jewel", "Joke", "Journey", "Joy", "Judge", "Juice", "Jungle", "Junk", "Jury", "Justice", "Karma", "Key", "Kid", "Kiln", "King", "Kiss", "Kitchen", "Kite", "Kitten", "Knife", "Knight", "Knot", "Kraken", "Label", "Labor", "Labyrinth", "Lace", "Ladder", "Lady", "Lagoon", "Lake", "Lamb", "Lament", "Lamp", "Lance", "Land", "Lantern", "Lark", "Larva", "Laser", "Lasso", "Lava", "Law", "Lead", "Leaf", "Leak", "Leech", "Legacy", "Legend", "Lemon", "Lens", "Leopard", "Leprechaun", "Lettuce", "Leviathan", "Liberty", "Librarian", "Library", "Lice", "Lich", "Lie", "Life", "Light", "Lightning", "Lily", "Lime", "Line", "Link", "Lion", "Lips", "Liquid", "Lizard", "Llama", "Loaf", "Loan", "Lobster", "Lock", "Locket", "Locust", "Log", "Logic", "Loom", "Loop", "Lord", "Lore", "Lotus", "Lounge", "Love", "Luck", "Lullaby", "Lumber", "Lump", "Lunch", "Lure", "Lust", "Lute", "Luxury", "Lyre", "Macaroni", "Machine", "Mage", "Magic", "Magma", "Magnet", "Maiden", "Mail", "Mammoth", "Man", "Mane", "Mantra", "Map", "Maple", "Marble", "March", "Mare", "Mark", "Market", "Mask", "Mass", "Master", "Match", "Matrix", "Matron", "Maze", "Meadow", "Meal", "Meat", "Medal", "Melody", "Melon", "Member", "Memory", "Menace", "Mentor", "Mercy", "Meridian", "Mesh", "Message", "Metal", "Meteor", "Microbe", "Milk", "Mill", "Mimic", "Mind", "Mine", "Mirage", "Mirror", "Mischief", "Missile", "Mist", "Mob", "Model", "Moloch", "Moment", "Monarch", "Money", "Monk", "Monkey", "Monster", "Moon", "Moose", "Morning", "Moss", "Moth", "Motion", "Motor", "Mountain", "Mouse", "Mouth", "Mud", "Muffin", "Mule", "Mummy", "Murder", "Muscle", "Museum", "Mushroom", "Music", "Musket", "Mutant", "Mutt", "Mystery", "Myth", "Nail", "Name", "Nation", "Nature", "Navy", "Nebula", "Neck", "Needle", "Nemesis", "Net", "Network", "Night", "Nimbus", "Ninja", "Nitro", "Noble", "Node", "Noise", "Nomad", "Noon", "Noodle", "North", "Nose", "Note", "Nothing", "Nova", "Novel", "Nuke", "Null", "Number", "Nut", "Nymph", "Oasis", "Oath", "Oatmeal", "Object", "Oblivion", "Obsidian", "Ocean", "Ochre", "Octagon", "Octopus", "Odor", "Odyssey", "Office", "Ogre", "Oil", "Ointment", "Omega", "Omen", "Onion", "Ooze", "Opal", "Opera", "Oracle", "Orb", "Orchard", "Orchestra", "Orc", "Order", "Organ", "Origin", "Ornament", "Orphan", "Ostrich", "Otter", "Outlet", "Outlaw", "Oven", "Overlord", "Owl", "Ox", "Oyster", "Package", "Pact", "Paddle", "Page", "Pain", "Paint", "Palace", "Palm", "Pancake", "Panda", "Panic", "Panther", "Pants", "Paper", "Parade", "Paradox", "Parasite", "Parchement", "Park", "Parrot", "Party", "Pasta", "Patch", "Path", "Patron", "Pawn", "Peace", "Peach", "Peacock", "Peanut", "Pear", "Pearl", "Peasant", "Pebble", "Pegasus", "Pelican", "Pen", "Pencil", "Pendant", "Pendulum", "Penguin", "Pepper", "Petal", "Phantom", "Phoenix", "Phone", "Photo", "Phrase", "Piano", "Pickle", "Pie", "Piece", "Pig", "Pigeon", "Pike", "Pilgrim", "Pill", "Pillar", "Pillow", "Pilot", "Pin", "Pine", "Pipe", "Pirate", "Piston", "Pit", "Pitch", "Pixel", "Pizza", "Plague", "Plain", "Plan", "Plane", "Planet", "Plank", "Plant", "Plasma", "Plate", "Platypus", "Player", "Plaza", "Plot", "Plume", "Pocket", "Poem", "Poet", "Point", "Poison", "Poker", "Pole", "Pollen", "Pond", "Pony", "Pool", "Popcorn", "Portal", "Portrait", "Post", "Potato", "Potion", "Powder", "Power", "Prayer", "Prey", "Price", "Pride", "Priest", "Prince", "Prism", "Prison", "Probe", "Problem", "Prodigy", "Program", "Project", "Prophet", "Proton", "Prowler", "Proxy", "Psalm", "Psyche", "Pudding", "Puddle", "Pulse", "Punch", "Punk", "Puppet", "Puppy", "Purge", "Pyramid", "Python", "Quake", "Quark", "Quarry", "Queen", "Quest", "Quill", "Rabbit", "Race", "Radish", "Rage", "Raider", "Rail", "Rain", "Rake", "Ram", "Rancor", "Ranger", "Rat", "Raven", "Ray", "Razor", "Realm", "Reaper", "Rebel", "Recipe", "Record", "Recruit", "Redeem", "Reef", "Reflex", "Refuge", "Relic", "Remedy", "Rent", "Reptile", "Requiem", "Reserve", "Resin", "Resort", "Rest", "Retreat", "Return", "Revelation", "Revenge", "Rhyme", "Rhythm", "Ribbon", "Rice", "Riddle", "Rider", "Rifle", "Rift", "Ring", "Riot", "Risk", "Rite", "Ritual", "River", "Road", "Roar", "Robe", "Robin", "Robot", "Rock", "Rocket", "Rod", "Rogue", "Roll", "Romance", "Roof", "Rook", "Room", "Root", "Rope", "Rose", "Rotor", "Round", "Route", "Ruby", "Ruin", "Ruler", "Rune", "Rust", "Saber", "Sack", "Sacrifice", "Sage", "Sail", "Salad", "Salamander", "Salt", "Salute", "Salvo", "Sanctum", "Sand", "Sarcasm", "Sauce", "Sausage", "Savage", "Savior", "Saw", "Scale", "Scarab", "Scarecrow", "Scarf", "Scent", "Scheme", "Scholar", "School", "Science", "Scimitar", "Scissors", "Scoop", "Scorpion", "Scout", "Scrap", "Scream", "Screen", "Screw", "Script", "Scroll", "Scythe", "Sea", "Seal", "Seam", "Search", "Season", "Seat", "Secret", "Sect", "Sector", "Seed", "Seer", "Seizure", "Senate", "Sense", "Sentinel", "Sentry", "Seraph", "Serenade", "Serpent", "Servant", "Server", "Shadow", "Shaft", "Shale", "Shaman", "Shame", "Shard", "Shark", "Shears", "Shed", "Sheep", "Shell", "Shelter", "Sheriff", "Shield", "Shift", "Shine", "Ship", "Shire", "Shock", "Shoe", "Shop", "Shore", "Shot", "Shovel", "Show", "Shred", "Shriek", "Shrine", "Shroud", "Sign", "Signal", "Silence", "Silk", "Silver", "Sin", "Singer", "Sire", "Siren", "Skeleton", "Skin", "Skull", "Sky", "Slab", "Slang", "Slave", "Sled", "Sleep", "Sleet", "Sleeve", "Slime", "Sling", "Slot", "Sloth", "Sludge", "Slug", "Smile", "Smoke", "Snake", "Snare", "Snow", "Soap", "Socket", "Soil", "Soldier", "Solitude", "Song", "Soot", "Sorcery", "Sorrow", "Soul", "Sound", "Soup", "South", "Space", "Spade", "Spam", "Spark", "Sparrow", "Spawn", "Spear", "Spell", "Sphere", "Spice", "Spider", "Spike", "Spin", "Spine", "Spiral", "Spire", "Spirit", "Spit", "Spite", "Spore", "Sport", "Spot", "Spring", "Sprite", "Spur", "Spy", "Squad", "Square", "Squash", "Squid", "Squirrel", "Staff", "Stage", "Stain", "Stair", "Stake", "Stall", "Stamp", "Stance", "Star", "Statue", "Steam", "Steel", "Stem", "Step", "Stew", "Stick", "Stigma", "Sting", "Stone", "Storm", "Story", "Stove", "Strain", "Strand", "Strap", "Stream", "Street", "Stress", "Strike", "String", "Strip", "Stroke", "Struggle", "Stub", "Student", "Study", "Stump", "Style", "Sugar", "Suit", "Sulfur", "Summer", "Sun", "Surge", "Swamp", "Swan", "Swarm", "Sweat", "Sweet", "Swift", "Swim", "Switch", "Sword", "Symbol", "Symphony", "Syndicate", "Synergy", "Synod", "Syrup", "System", "Tablet", "Tackle", "Taco", "Tact", "Tactic", "Tail", "Tale", "Talisman", "Talk", "Tank", "Tape", "Target", "Tarot", "Task", "Taste", "Tattoo", "Tavern", "Tea", "Tear", "Techno", "Temple", "Tempt", "Tent", "Terror", "Test", "Text", "Theft", "Theme", "Theory", "Thief", "Thistle", "Thorn", "Thought", "Thread", "Threat", "Throne", "Thumb", "Thunder", "Thyme", "Ticket", "Tide", "Tiger", "Tile", "Time", "Tin", "Tip", "Titan", "Toast", "Tobacco", "Token", "Tomb", "Tone", "Tongue", "Tool", "Tooth", "Topaz", "Torch", "Tornado", "Torrent", "Tortoise", "Totem", "Touch", "Tour", "Tower", "Town", "Toxin", "Toy", "Trace", "Track", "Trade", "Tragedy", "Trail", "Train", "Trait", "Traitor", "Trance", "Trap", "Trash", "Travel", "Treason", "Treasure", "Treaty", "Tree", "Trench", "Trend", "Trial", "Triangle", "Tribe", "Trick", "Trident", "Trigger", "Trinity", "Trinket", "Trip", "Triumph", "Troll", "Troop", "Trophy", "Trouble", "Trout", "Truck", "Trumpet", "Trunk", "Trust", "Truth", "Try", "Tube", "Tundra", "Tune", "Tunnel", "Turban", "Turf", "Turkey", "Turtle", "Tusk", "Tutor", "Twig", "Twilight", "Twin", "Twist", "Tycoon", "Tyrant", "Udon", "Ulcer", "Umbra", "Umbrella", "Undead", "Underdog", "Unicorn", "Uniform", "Union", "Unit", "Universe", "Uprising", "Urchin", "Urn", "Vacuum", "Vagrant", "Vale", "Valley", "Valor", "Valve", "Vampire", "Vandal", "Vanilla", "Vapor", "Vault", "Veil", "Vein", "Velvet", "Venom", "Vent", "Venue", "Verdict", "Verse", "Vessel", "Vest", "Veteran", "Vial", "Vibe", "Vice", "Victim", "Victor", "Video", "View", "Vigil", "Viking", "Village", "Vine", "Vinegar", "Violation", "Violence", "Violet", "Viper", "Virtue", "Virus", "Visage", "Vision", "Visitor", "Vista", "Voice", "Void", "Volcano", "Volt", "Volume", "Vortex", "Vote", "Vow", "Vowel", "Voyage", "Vulture", "Waffle", "Wagon", "Waist", "Walk", "Wall", "Walnut", "Walrus", "Waltz", "Wand", "War", "Warden", "Wardrobe", "Warlock", "Warmth", "Warning", "Warp", "Warrior", "Wasp", "Waste", "Watch", "Water", "Wave", "Wax", "Way", "Weapon", "Weasel", "Weather", "Web", "Weed", "Week", "Weight", "Well", "Whale", "Wheat", "Wheel", "Whip", "Whisper", "Whistle", "Wick", "Widow", "Wight", "Wilderness", "Will", "Willow", "Wind", "Window", "Wine", "Wing", "Winter", "Wire", "Wisdom", "Wish", "Wisp", "Witch", "Witness", "Wizard", "Woe", "Wolf", "Woman", "Wombat", "Wonder", "Wood", "Wool", "Word", "Work", "World", "Worm", "Worry", "Wound", "Wrath", "Wreck", "Wrench", "Writer", "Xenon", "Xylophone", "Yacht", "Yak", "Yam", "Yarn", "Year", "Yeast", "Yeti", "Yield", "Yoga", "Yogurt", "Yolk", "Youth", "Zealot", "Zebra", "Zenith", "Zephyr", "Zero", "Zeus", "Zigzag", "Zinc", "Zombie", "Zone", "Zoo", "Banana", "Pickle", "Robot", "Ninja", "Unicorn", "Pirate", "Muffin", "Gnome", "Dragon", "Alabama", "Penguin", "Potato", "Pancake"];

            // [Your NAME_PART_ADJECTIVES and NAME_PART_NOUNS arrays are assumed to be here in your local file]

            promptForm.addEventListener('change', () => {
                // When prompt type changes, update tooltips of all visible regenerate buttons
                imageQueue.forEach(item => {
                    if (item.status === 'Completed' || item.status === 'Error') {
                        const itemDiv = document.getElementById(item.id);
                        if (itemDiv) {
                            const regenerateBtn = itemDiv.querySelector(`#regenerate-${item.id}`);
                            if (regenerateBtn && regenerateBtn.style.display !== 'none') {
                                // Re-call updateQueueItemUI for this item to refresh its tooltip and state
                                updateQueueItemUI(item);
                            }
                        }
                    }
                });
            });

            function logToConsole(message, type = 'info', durationSeconds = null) {
                if (consoleLogDiv.style.display === 'none') {
                    consoleLogDiv.style.display = 'block';
                }
                const messageP = document.createElement('p');
                const time = new Date();
                const timestampSpan = document.createElement('span');
                timestampSpan.className = 'timestamp';
                timestampSpan.textContent = `[${time.getHours().toString().padStart(2,'0')}:${time.getMinutes().toString().padStart(2,'0')}:${time.getSeconds().toString().padStart(2,'0')}]`;
                
                messageP.appendChild(timestampSpan);
                messageP.appendChild(document.createTextNode(" " + message));

                if (durationSeconds !== null) {
                    const durationSpan = document.createElement('span');
                    durationSpan.className = 'duration';
                    durationSpan.textContent = `(took ${durationSeconds.toFixed(2)}s)`;
                    messageP.appendChild(durationSpan);
                }
                
                let typeClass = 'console-info';
                if (type === 'success') typeClass = 'console-success';
                else if (type === 'warning') typeClass = 'console-warning';
                else if (type === 'error') typeClass = 'console-error';
                messageP.classList.add(typeClass);

                consoleMessagesDiv.prepend(messageP);

                if (consoleMessagesDiv.children.length > MAX_CONSOLE_MESSAGES) {
                    consoleMessagesDiv.removeChild(consoleMessagesDiv.lastChild);
                }
                consoleMessagesDiv.scrollTop = 0; // Scroll to top to show latest message
            }

            function generateRandomName() {
                // Ensure your NAME_PART_ADJECTIVES and NAME_PART_NOUNS are defined
                if (typeof NAME_PART_ADJECTIVES === 'undefined' || typeof NAME_PART_NOUNS === 'undefined' || NAME_PART_ADJECTIVES.length === 0 || NAME_PART_NOUNS.length === 0) {
                    console.warn("Name generation arrays not found or empty. Using generic name.");
                    return `Image-${Date.now().toString().slice(-5)}`;
                }
                const adj = NAME_PART_ADJECTIVES[Math.floor(Math.random() * NAME_PART_ADJECTIVES.length)];
                const noun = NAME_PART_NOUNS[Math.floor(Math.random() * NAME_PART_NOUNS.length)];
                return `${adj}${noun}`;
            }

            function getPromptText() { 
                const selectedPromptType = promptForm.elements['promptType'].value;
                if (selectedPromptType === 'sd') {
                    return "Output a long stable diffusion prompt that is indistinguishable from a real stable diffusion prompt.";
                } else if (selectedPromptType === 'danbooru') {
                    return "Generate only comma-separated Danbooru tags (lowercase_underscores). Strict order: `artist:`, `copyright:`, `character:`, `meta:`, then general tags. Include counts (1girl), appearance, clothing, accessories, pose, expression, actions, background. Use precise Danbooru syntax. No extra text. long length.";
                }
                return ""; // Should not happen with radio buttons
            }
            
            function filterApiResponse(responseText, promptType) {
                if (responseText === null || typeof responseText === 'undefined') return "";
                let filteredText = String(responseText);

                filteredText = filteredText.replace(/```json|```text|```/gi, '').trim();
                filteredText = filteredText.replace(/^Sure, here is[^:]*:\s*/i, '');
                filteredText = filteredText.replace(/^Okay, here are the tags:\s*/i, '');
                filteredText = filteredText.replace(/^Here are the Danbooru tags:\s*/i, '');


                if (promptType === 'sd') {
                    const forbiddenSubstrings = [
                        'artist', 'watermark', 'logo', 'artist name', 
                        'signed by', 'artist mark', 'brand logo', 'company logo', 'text overlay',
                        'user', 'author', 'username', 'signature', 'artist\'s', 'author\'s', 'user\'s', 'username\'s'
                    ];
                    let phrases = filteredText.split(',').map(phrase => phrase.trim());
                    
                    phrases = phrases.filter(phrase => {
                        if (!phrase) return false;
                        const lowerPhrase = phrase.toLowerCase();
                        return !forbiddenSubstrings.some(forbidden => lowerPhrase.includes(forbidden.toLowerCase()));
                    });
                    
                    filteredText = phrases.filter(p => p.length > 0).join(', ').replace(/,$/, '').trim();
                } else if (promptType === 'danbooru') {
                    const tagsToRemove = [
                        'signature', 'artist_signature', 'watermark', 'logo', 'text', 
                        'english_text', 'speech_bubble', 'artist_name_tag_me', 'tagme', 
                        'artist_name', 'company_logo', 'brand_logo', 'text_overlay',
                        'username', 'author_signature', 'user_signature'
                    ];
                    
                    let tags = filteredText.split(',')
                        .map(tag => tag.trim().toLowerCase().replace(/ /g, '_'))
                        .filter(tag => tag.length > 0); 
                    
                    tags = tags.filter(tag => {
                        if (!tag) return false; 
                        if (tagsToRemove.includes(tag)) return false;
                        if (tag.includes(':tagme') || tag.endsWith('_tagme')) return false;
                        if (tag.startsWith("generate_") || tag.startsWith("output_") || tag.includes("tags_for_")) return false;
                        if (tag.includes("artist name here") || tag.includes("character name here") || tag.includes("copyright here")) return false;
                        return true;
                    });
                    filteredText = tags.filter(t => t.length > 0).join(', ').replace(/,$/, '').trim();
                }
                return filteredText;
            }

            async function fetchModels(baseUrl, apiKey = null) {
                if (!baseUrl) {
                    logToConsole('Base URL is required to fetch models.', 'warning');
                    apiConnectionStatus.textContent = 'Base URL is required.';
                    apiConnectionStatus.className = 'caption red-text text-darken-1';
                    return null;
                }
                const modelsUrl = baseUrl.replace(/\/$/, '') + '/v1/models'; // Ensure no double slash
                logToConsole(`Fetching models from ${modelsUrl}...`, 'info');
                if (apiConnectionStatus) { // Check if element exists, e.g. during initial headless tests
                    apiConnectionStatus.textContent = 'Fetching available models...';
                    apiConnectionStatus.className = 'caption grey-text text-darken-1';
                }

                try {
                    const headers = { 'Content-Type': 'application/json' };
                    if (apiKey) { headers['Authorization'] = `Bearer ${apiKey}`; }

                    const response = await fetch(modelsUrl, { method: 'GET', headers: headers, signal: AbortSignal.timeout(7000) });

                    if (!response.ok) {
                        const errorText = await response.text().catch(() => `Server returned status ${response.status}`);
                        throw new Error(`Failed to fetch models: ${response.status} ${errorText.substring(0,100)}`);
                    }
                    const data = await response.json();
                    if (data && data.data && Array.isArray(data.data)) {
                        const modelIds = data.data.map(model => model.id).filter(id => id);
                        logToConsole(`Successfully fetched ${modelIds.length} models.`, 'success');
                        if (apiConnectionStatus) {
                            apiConnectionStatus.textContent = `Successfully fetched ${modelIds.length} models.`;
                            apiConnectionStatus.className = 'caption green-text text-darken-1';
                        }
                        return modelIds;
                    } else {
                        throw new Error('Invalid model data format received.');
                    }
                } catch (error) {
                    logToConsole(`Error fetching models: ${error.message}`, 'error');
                    if (apiConnectionStatus) {
                        apiConnectionStatus.textContent = `Error fetching models: ${error.message.substring(0,150)}`;
                        apiConnectionStatus.className = 'caption red-text text-darken-1';
                    }
                    console.error("Fetch Models Error:", error);
                    return null; // Indicate failure
                }
            }

            function populateModelsDropdown(models, selectedModelId) {
                apiModelSelect.innerHTML = ''; // Clear existing options

                if (!models || models.length === 0) {
                    const option = document.createElement('option');
                    option.value = "";
                    option.textContent = "No models found or error";
                    option.disabled = true;
                    option.selected = true;
                    apiModelSelect.appendChild(option);
                } else {
                    let foundSelected = false;
                    models.forEach(modelId => {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        if (modelId === selectedModelId) {
                            option.selected = true;
                            foundSelected = true;
                        }
                        apiModelSelect.appendChild(option);
                    });
                    if (!foundSelected && models.length > 0) {
                        apiModelSelect.value = models[0]; // Select the first model if preferred one wasn't found
                    }
                }
                // Re-initialize Materialize select
                M.FormSelect.init(apiModelSelect);
            }

            // --- API Modal Functions ---
            async function testApiConnection(chatEndpointUrl, modelId, silent = false, apiKey = null) {
                let uiShouldBeUnlocked = false; // Renamed for clarity in this context
                if (!silent) {
                    apiConnectionStatus.textContent = 'Testing chat connection...';
                    apiConnectionStatus.className = 'caption grey-text text-darken-1'; 
                }

                if (!modelId && !silent) {
                    apiConnectionStatus.textContent = 'No model selected/available for testing chat endpoint.';
                    apiConnectionStatus.className = 'caption orange-text text-darken-1';
                    return false; 
                }
                if (!chatEndpointUrl && !silent) {
                    apiConnectionStatus.textContent = 'Chat endpoint URL is missing for test.';
                    apiConnectionStatus.className = 'caption red-text text-darken-1';
                    return false;
                }


                try {
                    const headers = { 'Content-Type': 'application/json' };
                    if (apiKey) { headers['Authorization'] = `Bearer ${apiKey}`; }

                    const testPayload = { model: modelId || "test-model", messages: [{role:"user", content:"ping"}], max_tokens: 1, stream: false };
                    const response = await fetch(chatEndpointUrl, { method: 'POST', headers: headers, body: JSON.stringify(testPayload), signal: AbortSignal.timeout(7000) }); 
                    
                    const status = response.status;
                    let feedbackMessage = ''; let feedbackClass = 'caption red-text text-darken-1';

                    if ((status >= 200 && status < 300)) {
                        feedbackMessage = `Chat Connection successful! (Model: ${modelId}, Status: ${status})`; feedbackClass = 'caption green-text text-darken-1'; uiShouldBeUnlocked = true;
                    } else if (status === 400 || status === 422) {
                        feedbackMessage = `Bad request (model/params). Status: ${status}. API is responding.`; feedbackClass = 'caption orange-text text-darken-1'; uiShouldBeUnlocked = true;
                    } else if (status === 404) {
                        feedbackMessage = `Endpoint/Model not found. Status: ${status}. API is responding.`; feedbackClass = 'caption orange-text text-darken-1'; uiShouldBeUnlocked = true;
                    } else if (status === 401) {
                        feedbackMessage = `Authentication error (401). Check API Key.`;
                    } else if (status === 403) {
                        feedbackMessage = `Forbidden (403). Check API Key permissions.`;
                    } else { 
                        const errorText = await response.text().catch(() => `Server returned status ${status}`);
                        feedbackMessage = `Server error or unexpected issue. Status: ${status}. Message: ${errorText.substring(0,100)}`;
                    }
                    if (!silent) { apiConnectionStatus.textContent = feedbackMessage; apiConnectionStatus.className = feedbackClass; }
                    return uiShouldBeUnlocked;
                } catch (error) { 
                    if (!silent) {
                        let errorMessage = `Chat Connection failed: ${error.message.substring(0,150)}`;
                        if (error.name === 'AbortError') errorMessage = 'Connection timed out.';
                        else if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                             errorMessage = 'Network error or CORS issue. Check console & server CORS headers.';
                        }
                        apiConnectionStatus.textContent = errorMessage;
                        apiConnectionStatus.className = 'caption red-text text-darken-1';
                    }
                    console.error("API Chat Connection Test Error:", error);
                    return false;
                }
            }

            function openForceConfigModal(message) {
                settingsModalTitle.textContent = "Configuration Required";
                settingsModalInstance.options.dismissible = false;
                closeApiSettingsButton.style.display = 'none';
                pageBlurOverlay.classList.add('active');
                if (!settingsModalInstance.isOpen) {
                    settingsModalInstance.open();
                }
                imageQueue.forEach(it => updateQueueItemUI(it));
                setTimeout(() => { if (document.activeElement !== apiBaseUrlInput) apiBaseUrlInput.focus(); }, 200);
            }

            function makeModalDismissibleAndOptional() {
                settingsModalTitle.textContent = "API Settings";
                settingsModalInstance.options.dismissible = true;
                closeApiSettingsButton.style.display = 'inline-block';
                pageBlurOverlay.classList.remove('active');
                updateQueueControls();
                imageQueue.forEach(it => updateQueueItemUI(it));
            }
            
            saveApiSettingsButton.addEventListener('click', async () => {
                // --- Gather All Input Values ---
                const baseUrl = apiBaseUrlInput.value.trim();
                const chatPath = apiChatPathInput.value.trim();
                const key = apiKeyInput.value.trim() || null;
                const newRawDelimiter = rawOutputDelimiterInput.value; // User types '\n', JS sees it as a literal newline if not escaped. If they type '\\n', JS sees '\\n'. Let's assume they type \n for newline.
                const newJsonSchema = jsonOutputSchemaInput.value.trim();

                // --- Validate Output Format Settings ---
                if (!newJsonSchema) {
                    apiConnectionStatus.textContent = 'JSON Output Schema template cannot be empty.';
                    apiConnectionStatus.className = 'caption red-text text-darken-1';
                    jsonOutputSchemaInput.focus();
                    M.textareaAutoResize(jsonOutputSchemaInput); // Trigger resize
                    return;
                }
                // Basic check: a schema should generally start with { or [
                if (!newJsonSchema.startsWith('{') && !newJsonSchema.startsWith('[')) {
                    apiConnectionStatus.textContent = 'JSON Schema should be a valid JSON structure (e.g., start with { or [ ).';
                    apiConnectionStatus.className = 'caption red-text text-darken-1';
                    jsonOutputSchemaInput.focus();
                    M.textareaAutoResize(jsonOutputSchemaInput);
                    return;
                }
                // The rawOutputDelimiter can be empty, that's fine (means outputs joined directly).

                // --- API Settings Validation (existing logic) ---
                if (!baseUrl) {
                    apiConnectionStatus.textContent = 'Base Server URL cannot be empty.';
                    apiConnectionStatus.className = 'caption red-text text-darken-1';
                    apiBaseUrlInput.focus();
                    return;
                }
                if (!chatPath) {
                    apiConnectionStatus.textContent = 'Chat Completion Path cannot be empty.';
                    apiConnectionStatus.className = 'caption red-text text-darken-1';
                    apiChatPathInput.focus();
                    return;
                }

                apiConnectionStatus.textContent = 'Saving: Fetching models...';
                apiConnectionStatus.className = 'caption grey-text text-darken-1';

                const fetchedModels = await fetchModels(baseUrl, key);

                if (fetchedModels && fetchedModels.length > 0) {
                    availableModels = fetchedModels;
                    let modelToSave = apiModelSelect.value;
                    if (!modelToSave || !fetchedModels.includes(modelToSave)) {
                        modelToSave = fetchedModels.includes(currentSelectedModel) ? currentSelectedModel : fetchedModels[0];
                    }
                    populateModelsDropdown(availableModels, modelToSave);

                    apiConnectionStatus.textContent = 'Saving: Testing chat connection...';
                    const fullChatEndpoint = baseUrl.replace(/\/$/, '') + chatPath;
                    const connectionUsable = await testApiConnection(fullChatEndpoint, modelToSave, false, key);

                    if (connectionUsable) {
                        // API settings are good, NOW save everything
                        localStorage.setItem(BASE_SERVER_URL_KEY, baseUrl);
                        localStorage.setItem(CHAT_COMPLETION_PATH_KEY, chatPath);
                        localStorage.setItem(SELECTED_MODEL_KEY, modelToSave);
                        currentBaseUrl = baseUrl;
                        currentChatPath = chatPath;
                        currentSelectedModel = modelToSave;

                        if (key) { localStorage.setItem(API_KEY_KEY, key); }
                        else { localStorage.removeItem(API_KEY_KEY); }
                        currentApiKey = key;

                        // Save Output Format Settings
                        localStorage.setItem(RAW_DELIMITER_KEY, newRawDelimiter); // Store as user typed it e.g. "\n\n"
                        localStorage.setItem(JSON_SCHEMA_KEY, newJsonSchema);
                        currentRawDelimiter = newRawDelimiter;
                        currentJsonSchema = newJsonSchema;

                        logToConsole(`API & Output Settings updated. Delimiter: [${currentRawDelimiter.replace(/\n/g, "\\n").replace(/\t/g, "\\t")}], Model: ${modelToSave}`, 'success');
                        makeModalDismissibleAndOptional();
                        if (settingsModalInstance.isOpen) settingsModalInstance.close();
                    } else {
                        // testApiConnection already updated apiConnectionStatus
                        logToConsole(`Chat endpoint test failed. Settings not saved.`, 'error');
                        settingsModalInstance.options.dismissible = false;
                        closeApiSettingsButton.style.display = 'none';
                        pageBlurOverlay.classList.add('active');
                        if (!settingsModalInstance.isOpen) settingsModalInstance.open();
                    }
                } else {
                    // fetchModels already updated apiConnectionStatus and logged error
                    logToConsole(`Failed to fetch models. API settings not saved.`, 'error');
                    populateModelsDropdown(null, null);
                    settingsModalInstance.options.dismissible = false;
                    closeApiSettingsButton.style.display = 'none';
                    pageBlurOverlay.classList.add('active');
                    if (!settingsModalInstance.isOpen) settingsModalInstance.open();
                    apiBaseUrlInput.focus();
                }
            });
            
            testApiSettingsButton.addEventListener('click', async () => {
                const baseUrl = apiBaseUrlInput.value.trim();
                const chatPath = apiChatPathInput.value.trim();
                const key = apiKeyInput.value.trim() || null;
                const modelFromDropdown = apiModelSelect.value;

                if (!baseUrl) {
                    apiConnectionStatus.textContent = 'Base URL is required for testing.';
                    apiConnectionStatus.className = 'caption red-text text-darken-1';
                    return;
                }
                 if (!chatPath) {
                    apiConnectionStatus.textContent = 'Chat Path is required for testing.';
                    apiConnectionStatus.className = 'caption red-text text-darken-1';
                    return;
                }

                apiConnectionStatus.textContent = 'Testing: Fetching models...';
                apiConnectionStatus.className = 'caption grey-text text-darken-1';
                const fetchedModels = await fetchModels(baseUrl, key);

                if (fetchedModels && fetchedModels.length > 0) {
                    // Populate dropdown, try to keep current selection or pick first
                    const modelToTestWith = fetchedModels.includes(modelFromDropdown) ? modelFromDropdown : fetchedModels[0];
                    populateModelsDropdown(fetchedModels, modelToTestWith); 
                    
                    if (!modelToTestWith) { // Should not happen if fetchedModels is not empty
                         apiConnectionStatus.textContent = 'No model available in dropdown for chat test.';
                         apiConnectionStatus.className = 'caption orange-text text-darken-1';
                         return;
                    }
                    
                    const fullChatEndpoint = baseUrl.replace(/\/$/, '') + chatPath;
                    // testApiConnection will update the status message for chat test
                    await testApiConnection(fullChatEndpoint, modelToTestWith, false, key);
                } else {
                    // fetchModels already updated status.
                    populateModelsDropdown(null, null); // Show error in dropdown
                }
            });

            // Initial API setup check
            apiBaseUrlInput.value = currentBaseUrl;
            apiChatPathInput.value = currentChatPath;
            // Model dropdown will be populated by initialApiSetup
            if (currentApiKey) apiKeyInput.value = currentApiKey;

            async function initialApiSetup() {
                logToConsole("Performing initial API setup check...", "info");
                const models = await fetchModels(currentBaseUrl, currentApiKey);
                
                if (models && models.length > 0) {
                    availableModels = models;
                    // Ensure currentSelectedModel is valid, otherwise pick first or default (e.g. hardcoded preferred)
                    if (!availableModels.includes(currentSelectedModel)) {
                        const defaultPreferredModel = 'llama-joycaption-beta-one-hf-llava-mmproj';
                        currentSelectedModel = availableModels.includes(defaultPreferredModel) ? defaultPreferredModel : availableModels[0];
                        // Optionally update localStorage if currentSelectedModel was invalid and changed
                        // localStorage.setItem(SELECTED_MODEL_KEY, currentSelectedModel); 
                    }
                    populateModelsDropdown(availableModels, currentSelectedModel);
                    apiModelSelect.value = currentSelectedModel; // Ensure dropdown reflects this
                    M.FormSelect.init(apiModelSelect); // Re-init after setting value

                    const fullChatEndpoint = currentBaseUrl.replace(/\/$/, '') + currentChatPath;
                    const isUsableChatConnection = await testApiConnection(fullChatEndpoint, currentSelectedModel, true, currentApiKey);
                    
                    if (isUsableChatConnection) {
                        makeModalDismissibleAndOptional();
                        logToConsole("API settings loaded and connection verified.", "success");
                    } else {
                        // Models fetched, but chat test failed
                        openForceConfigModal('Fetched models, but chat endpoint test failed. Please verify paths/model or reconfigure.');
                    }
                } else {
                    // Failed to fetch models
                    populateModelsDropdown(null, null); // Show error in dropdown
                    const message = localStorage.getItem(BASE_SERVER_URL_KEY) ? 
                                    'Could not fetch models with stored settings. Please reconfigure.' : 
                                    'API not configured. Please set server URL and test to begin.';
                    openForceConfigModal(message);
                }
            }
            initialApiSetup(); // Call the setup function

            // --- Sidenav Layout & Control ---
            function updateSidenavLayout() {
                if (window.innerWidth >= 993 && isSidenavPersistent) {
                    // sidenavElem.classList.remove('sidenav-persistent');
                    if (sidenavInstance.isOpen) sidenavInstance.close(); // Close Materialize overlay if switching to persistent
                } else {
                    sidenavElem.classList.add('sidenav-persistent');
                    // Materialize Sidenav instance will handle opening/closing as an overlay
                }
            }

            // sidenavTrigger.addEventListener('click', (e) => {
            //     e.preventDefault();
            //     if (window.innerWidth >= 993) {
            //         isSidenavPersistent = !isSidenavPersistent;
            //         localStorage.setItem(SIDENAV_PERSISTENT_KEY, isSidenavPersistent);
            //         updateSidenavLayout();
            //     } else {
            //         sidenavInstance.isOpen ? sidenavInstance.close() : sidenavInstance.open();
            //     }
            // });

            // window.addEventListener('resize', () => {
            //     const largeScreen = window.innerWidth >= 993;
            //     if (!largeScreen && isSidenavPersistent) {
            //         isSidenavPersistent = false;
            //         localStorage.setItem(SIDENAV_PERSISTENT_KEY, isSidenavPersistent);
            //     } else if (largeScreen && localStorage.getItem(SIDENAV_PERSISTENT_KEY) !== null) {
            //         isSidenavPersistent = localStorage.getItem(SIDENAV_PERSISTENT_KEY) === 'true';
            //     } else if (largeScreen && localStorage.getItem(SIDENAV_PERSISTENT_KEY) === null) {
            //         isSidenavPersistent = true;
            //         localStorage.setItem(SIDENAV_PERSISTENT_KEY, isSidenavPersistent);
            //     }
            //     updateSidenavLayout();
            // });
            
            updateSidenavLayout(); // Initial call

            // --- Queue Management Functions ---
            function addImageToQueue(file, source = 'upload') {
                if (!file || !file.type.startsWith('image/')) {
                    logToConsole('Invalid file type. Please select an image.', 'warning'); return;
                }
                const reader = new FileReader();
                reader.onload = function(e) {
                    const base64Image = e.target.result;
                    const itemId = `img-${Date.now()}-${Math.random().toString(36).substring(2,9)}`;
                    const displayName = generateRandomName();
                    
                    const queueItem = {
                        id: itemId,
                        base64Image,
                        status: 'Pending',
                        output: null,
                        error: null,
                        displayTitle: displayName,
                        copied: false,
                        promptTypeUsed: null // Added this line
                    };
                    imageQueue.push(queueItem);
                    renderQueueItem(queueItem); 
                    updateQueueControls();
                    logToConsole(`Image "${displayName}" added to queue from ${source}.`, 'success');
                    
                    if (window.innerWidth < 993 && !sidenavInstance.isOpen && !isSidenavPersistent) {
                        sidenavInstance.open();
                    }
                }
                reader.readAsDataURL(file);
            }

            function renderQueueItem(item) {
                emptyQueueMessageSidenav.style.display = 'none';
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('queue-item');
                itemDiv.id = item.id;

                itemDiv.innerHTML = `
                    <img src="${item.base64Image}" alt="${item.displayTitle}" class="queue-item-thumbnail">
                    <div class="queue-item-details">
                        <span class="queue-item-title">${item.displayTitle}</span>
                        <span class="queue-item-status" id="status-${item.id}">${item.status}</span>
                        <div class="queue-item-output" id="output-${item.id}" style="display: none;"></div>
                    </div>
                    <div class="queue-item-actions">
                        <button id="copy-${item.id}" class="btn-floating btn-small waves-effect waves-light tooltipped" data-position="left" data-tooltip="Copy Output" style="display:none;margin-right:0.5rem;"><i class="material-icons">content_copy</i></button>
                        <button id="regenerate-${item.id}" class="btn-floating btn-small waves-effect waves-light tooltipped" data-position="left" data-tooltip="Regenerate" style="display:none;margin-right:0.5rem;"><i class="material-icons">sync</i></button>
                        <button id="remove-${item.id}" class="btn-floating btn-small waves-effect waves-light red tooltipped" data-position="left" data-tooltip="Remove"><i class="material-icons">delete_outline</i></button>
                    </div>
                `;
                imageQueueAreaSidenav.appendChild(itemDiv);
                M.Tooltip.init(itemDiv.querySelectorAll('.tooltipped'));

                itemDiv.querySelector(`#copy-${item.id}`).addEventListener('click', () => copyItemOutput(item));
                itemDiv.querySelector(`#remove-${item.id}`).addEventListener('click', () => removeQueueItem(item.id));
                itemDiv.querySelector(`#regenerate-${item.id}`).addEventListener('click', () => regenerateQueueItem(item.id));
            }

            function copyItemOutput(item) {
                const textToCopy = item.output || (item.status === 'Error' ? item.error : null);
                if (textToCopy === null || typeof textToCopy === 'undefined') {
                    logToConsole(`No output to copy for "${item.displayTitle}".`, 'warning'); return;
                }
                copyToClipboard(String(textToCopy), `Output for "${item.displayTitle}" copied!`);
                item.copied = true;
                const copyBtn = document.querySelector(`#copy-${item.id}`);
                if (copyBtn) {
                    copyBtn.classList.add('copied');
                    copyBtn.querySelector('i').textContent = 'check';
                    const tooltipInstance = M.Tooltip.getInstance(copyBtn);
                    if (tooltipInstance) { tooltipInstance.destroy(); copyBtn.setAttribute('data-tooltip', 'Copied!'); M.Tooltip.init(copyBtn); }
                }
            }
            
            function removeQueueItem(itemId) {
                const itemIndex = imageQueue.findIndex(item => item.id === itemId);
                if (itemIndex > -1) {
                    const item = imageQueue[itemIndex];
                    if (item.status === 'Processing') { 
                        logToConsole(`Cannot remove "${item.displayTitle}" while it is processing.`, 'warning'); return; 
                    }
                    const itemDiv = document.getElementById(itemId);
                    if (itemDiv) {
                        itemDiv.querySelectorAll('.tooltipped').forEach(el => { const i = M.Tooltip.getInstance(el); if (i) i.destroy(); });
                        itemDiv.remove();
                    }
                    imageQueue.splice(itemIndex, 1);
                    updateQueueControls();
                    logToConsole(`"${item.displayTitle}" removed from queue.`, 'info');
                    if (imageQueue.length === 0) emptyQueueMessageSidenav.style.display = 'block';
                }
            }

            async function regenerateQueueItem(itemId) {
                if (isProcessing) {
                    logToConsole('Cannot regenerate item: Main queue is processing.', 'warning');
                    M.toast({ html: 'Main queue is processing!' });
                    return;
                }
                if (isSingleItemProcessing) {
                    logToConsole('Cannot regenerate item: Another item is already being regenerated.', 'warning');
                    M.toast({ html: 'Another item is processing!' });
                    return;
                }
                const isApiConfigured = settingsModalInstance.options.dismissible;
                if (!isApiConfigured) {
                    logToConsole('API not configured. Cannot regenerate.', 'warning');
                    M.toast({ html: 'API not configured. Cannot regenerate.' });
                    return;
                }

                const item = imageQueue.find(it => it.id === itemId);
                if (!item) {
                    logToConsole(`Item ${itemId} not found for regeneration.`, 'error');
                    return;
                }

                if (item.status !== 'Completed' && item.status !== 'Error') {
                    logToConsole(`Item "${item.displayTitle}" is not in a state that allows regeneration.`, 'warning');
                    return;
                }

                isSingleItemProcessing = true;
                item.status = 'Processing';
                item.output = null;
                item.error = null;
                item.copied = false;
                // item.promptTypeUsed will be set after successful processing
                updateQueueItemUI(item); // Show "Processing" status, disable its own regenerate button
                updateQueueControls();   // Disable global process button potentially

                // Temporarily disable other regenerate buttons
                imageQueue.forEach(iqItem => {
                    if (iqItem.id !== item.id) updateQueueItemUI(iqItem);
                });


                const currentPromptType = promptForm.elements['promptType'].value;
                const promptTxt = getPromptText();
                logToConsole(`Regenerating "${item.displayTitle}" for ${currentPromptType}...`, 'info');
                const itemStartTime = performance.now();

                const payload = {
                    model: currentSelectedModel,
                    messages: [
                        { role: "system", content: "You are a helpful image captioner." },
                        {
                            role: "user",
                            content: [
                                { type: "text", text: promptTxt },
                                { type: "image_url", image_url: { url: item.base64Image } }
                            ]
                        }
                    ],
                    temperature: 0.6,
                    max_tokens: 512,
                    stream: true
                };
                const fetchHeaders = { 'Content-Type': 'application/json' };
                if (currentApiKey) fetchHeaders['Authorization'] = `Bearer ${currentApiKey}`;

                try {
                    const fullChatEndpointForProcessing = currentBaseUrl.replace(/\/$/, '') + currentChatPath;
                    const r = await fetch(fullChatEndpointForProcessing, { method: 'POST', headers: fetchHeaders, body: JSON.stringify(payload) });

                    if (!r.ok) {
                        const ed = await r.json().catch(() => ({ detail: `API Error ${r.status}` }));
                        throw new Error(`${ed.detail || `HTTP ${r.status}`}`);
                    }
                    if (!r.body) throw new Error("Response has no body (stream).");

                    const rd = r.body.getReader();
                    const dec = new TextDecoder();
                    let buf = '';
                    let fullTxt = '';
                    while (true) {
                        const { done, value } = await rd.read();
                        if (done) break;
                        buf += dec.decode(value, { stream: true });
                        let pos;
                        while ((pos = buf.indexOf('\n\n')) >= 0) {
                            const ln = buf.substring(0, pos).trim();
                            buf = buf.substring(pos + 2);
                            if (ln.startsWith('data: ')) {
                                const jd = ln.substring(6);
                                if (jd === '[DONE]') break;
                                try {
                                    const p = JSON.parse(jd);
                                    if (p.choices?.[0]?.delta?.content) fullTxt += p.choices[0].delta.content;
                                } catch (e) {
                                    console.warn("Stream JSON chunk parse error:", e, jd);
                                }
                            }
                        }
                        if (buf.includes('data: [DONE]')) break;
                    }
                    item.output = filterApiResponse(fullTxt.trim(), currentPromptType);
                    item.status = 'Completed';
                    item.promptTypeUsed = currentPromptType;
                    logToConsole(`Successfully regenerated "${item.displayTitle}".`, 'success', (performance.now() - itemStartTime) / 1000);
                } catch (e) {
                    item.status = 'Error';
                    item.error = e.message;
                    // item.promptTypeUsed remains what it was or null if first error
                    logToConsole(`Error regenerating "${item.displayTitle}": ${e.message.substring(0, 150)}`, 'error', (performance.now() - itemStartTime) / 1000);
                }

                isSingleItemProcessing = false;
                updateQueueItemUI(item); // Update the processed item
                updateQueueControls();   // Re-enable global process button if needed

                // Re-enable other regenerate buttons
                imageQueue.forEach(iqItem => {
                     updateQueueItemUI(iqItem);
                });
            }

            function updateQueueItemUI(item) {
                const itemDiv = document.getElementById(item.id);
                if (!itemDiv) return;
                const statusEl = itemDiv.querySelector(`#status-${item.id}`);
                const outputEl = itemDiv.querySelector(`#output-${item.id}`);
                const copyBtn = itemDiv.querySelector(`#copy-${item.id}`);
                const regenerateBtn = itemDiv.querySelector(`#regenerate-${item.id}`);
                const isApiConfigured = settingsModalInstance.options.dismissible;

                statusEl.textContent = item.status;
                statusEl.className = 'queue-item-status';
                if (item.status === 'Processing') statusEl.classList.add('processing');
                else if (item.status === 'Completed') statusEl.classList.add('completed');
                else if (item.status === 'Error') statusEl.classList.add('error');

                if (item.copied && (item.output || item.error)) {
                    copyBtn.classList.add('copied'); copyBtn.querySelector('i').textContent = 'check';
                    const tt = M.Tooltip.getInstance(copyBtn); if (tt) { tt.destroy(); copyBtn.setAttribute('data-tooltip', 'Copied!'); M.Tooltip.init(copyBtn); }
                } else {
                    copyBtn.classList.remove('copied'); copyBtn.querySelector('i').textContent = 'content_copy';
                    const tt = M.Tooltip.getInstance(copyBtn); if (tt) { tt.destroy(); copyBtn.setAttribute('data-tooltip', 'Copy Output'); M.Tooltip.init(copyBtn); }
                }

                if (item.output || item.error) {
                    outputEl.textContent = item.output || `Error: ${item.error}`;
                    outputEl.style.display = 'block';
                    outputEl.style.color = item.error ? 'var(--console-error-text)' : '';
                    copyBtn.style.display = 'inline-flex';
                } else {
                    outputEl.style.display = 'none';
                    copyBtn.style.display = 'none';
                }

                if (item.status === 'Completed' || item.status === 'Error') {
                    regenerateBtn.style.display = 'inline-flex';
                    const canRegenerate = !isProcessing && !isSingleItemProcessing && isApiConfigured; // Check new flag
                    regenerateBtn.disabled = !canRegenerate;

                    let tooltipText;
                    const currentGlobalPromptType = promptForm.elements['promptType'].value;
                    const promptTypeFriendlyName = currentGlobalPromptType === 'sd' ? "Stable Diffusion Prompt" : "Danbooru Tags";

                    if (isProcessing) {
                        tooltipText = "Cannot regenerate: Main queue is processing";
                    } else if (isSingleItemProcessing) {
                        tooltipText = "Cannot regenerate: Another item is processing";
                    } else if (!isApiConfigured) {
                        tooltipText = "Cannot regenerate: API not configured";
                    } else {
                        tooltipText = `Regenerate for: ${promptTypeFriendlyName}`;
                        if (item.promptTypeUsed && item.promptTypeUsed !== currentGlobalPromptType) {
                             tooltipText += ` (Original was: ${item.promptTypeUsed === 'sd' ? "Stable Diffusion Prompt" : "Danbooru Tags"})`;
                        }
                    }

                    const regenTooltipInstance = M.Tooltip.getInstance(regenerateBtn);
                    if (regenTooltipInstance) { regenTooltipInstance.destroy(); }
                    regenerateBtn.setAttribute('data-tooltip', tooltipText);
                    M.Tooltip.init(regenerateBtn);

                } else {
                    regenerateBtn.style.display = 'none';
                }
            }
            
            function updateQueueControls() { 
                const pendingItemsCount = imageQueue.filter(item => item.status === 'Pending').length;
                const isApiReady = settingsModalInstance.options.dismissible;

                if (queueCountSidenavSpan) { // Check if the element exists
                    queueCountSidenavSpan.textContent = imageQueue.length;
                } else {
                    console.error("queueCountSidenavSpan not found!"); // Log error if it's missing
                }
                
                processQueueButton.disabled = !isApiReady || isProcessing || isSingleItemProcessing || pendingItemsCount === 0;
                clearQueueButton.disabled = isProcessing || isSingleItemProcessing || imageQueue.length === 0;

                if (!isApiReady) {
                    processQueueButton.innerHTML = 'Configure API <i class="material-icons right">settings</i>';
                } else if (isProcessing) {
                    // Text is set in the processing loop
                } else if (isSingleItemProcessing) {
                    processQueueButton.innerHTML = 'Item Regenerating... <i class="material-icons right spin">autorenew</i>';
                } else if (pendingItemsCount === 0 && imageQueue.length > 0) {
                    processQueueButton.innerHTML = 'All Processed <i class="material-icons right">done_all</i>';
                } else {
                    processQueueButton.innerHTML = `Process Queue ${imageQueue.length > 0 ? '('+pendingItemsCount+')' : ''} <i class="material-icons right">playlist_play</i>`;
                }
                
                if (imageQueue.length === 0) {
                    if (emptyQueueMessageSidenav) emptyQueueMessageSidenav.style.display = 'block';
                } else {
                    if (emptyQueueMessageSidenav) emptyQueueMessageSidenav.style.display = 'none';
                }

                // --- Export Buttons Logic ---
                const completedItemsCount = imageQueue.filter(item => item.status === 'Completed' && item.output && item.output.trim() !== '').length;
                const shouldBeDisabled = completedItemsCount === 0 || isProcessing || isSingleItemProcessing;

                // Helper to manage button state and tooltip
                function configureButton(button, isDisabled, enabledTooltipText, disabledTooltipText) {
                    if (!button) return; 

                    const newTooltipText = isDisabled ? disabledTooltipText : enabledTooltipText;
                    const existingTooltipInstance = M.Tooltip.getInstance(button);
                    if (existingTooltipInstance) {
                        existingTooltipInstance.destroy();
                    }
                    button.setAttribute('data-tooltip', newTooltipText);
                    M.Tooltip.init(button);

                    if (isDisabled) {
                        button.classList.add('disabled');
                        button.setAttribute('disabled', '');
                        button.setAttribute('aria-disabled', 'true');
                    } else {
                        button.classList.remove('disabled');
                        button.removeAttribute('disabled');
                        button.setAttribute('aria-disabled', 'false');
                    }
                }

                configureButton(
                    copyAllOutputsButton,
                    shouldBeDisabled,
                    "Copy All Outputs",
                    "Nothing to copy or processing"
                );

                configureButton(
                    downloadAllOutputsButton,
                    shouldBeDisabled,
                    "Download All Outputs",
                    "Nothing to download or processing"
                );
            }

            // --- Event Listeners for Image Input ---
            imageUploadInput.addEventListener('change', (event) => { 
                if (event.target.files?.length) {
                    for (const file of event.target.files) { addImageToQueue(file, 'upload'); }
                    event.target.value = ''; 
                    const fip = document.querySelector('#uploadTab .file-path'); if (fip) fip.value = '';
                }
            });
            addImageFromUrlButton.addEventListener('click', async () => { 
                const url = imageUrlInput.value.trim(); if (!url) { logToConsole('Please enter an Image URL.', 'warning'); return; }
                logToConsole('Fetching image from URL...', 'info');
                try {
                    const r = await fetch(url); if (!r.ok) throw new Error(`HTTP ${r.status} ${r.statusText}`);
                    const b = await r.blob(); if (!b.type.startsWith('image/')) { logToConsole('URL does not point to a valid image.', 'warning'); return; }
                    const filename = (url.substring(url.lastIndexOf('/')+1) || "from_url.png").replace(/[?#].*/, "");
                    addImageToQueue(new File([b], filename, { type: b.type }), 'url');
                    imageUrlInput.value = '';
                } catch (e) { logToConsole(`Error fetching from URL: ${e.message}`, 'error'); }
            });
            pasteArea.addEventListener('click', () => logToConsole('Paste image from clipboard (Ctrl+V or Cmd+V).', 'info'));
            pasteArea.addEventListener('paste', (event) => { 
                event.preventDefault(); const items = event.clipboardData?.items;
                if (!items) { logToConsole('No clipboard items found.', 'warning'); return; }
                for (let item of items) { 
                    if (item.type.includes('image')) { 
                        const file = item.getAsFile();
                        if (file) { addImageToQueue(file, 'paste'); } 
                        else { logToConsole('Could not retrieve pasted image.', 'warning'); }
                        return; 
                    }
                }
                logToConsole('No image found in clipboard.', 'warning');
            });

            // --- Global Paste Handler (Ctrl+V / Cmd+V) ---
            document.addEventListener('paste', async function(event) {
                const target = event.target;

                // 1. If the paste is happening directly into an input, textarea,
                //    or the dedicated pasteArea, let the default/specific behavior handle it.
                if (target.tagName === 'INPUT' || 
                    target.tagName === 'TEXTAREA' || 
                    target.isContentEditable || // Catches contenteditable elements
                    target.id === 'pasteArea') { // Specifically for your paste area
                    return; // Do nothing, let the existing handler or default behavior work
                }

                const items = event.clipboardData?.items;
                if (!items) {
                    return; // No clipboard items
                }

                let hasPastedImage = false;
                const tabsInstance = M.Tabs.getInstance(document.querySelector('.tabs'));

                // 2. Prioritize pasting an image
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    if (item.type.includes('image')) {
                        event.preventDefault(); // Prevent default paste action (e.g., browser trying to display image)
                        const file = item.getAsFile();
                        if (file) {
                            // Switch to the "Paste" tab
                            if (tabsInstance) {
                                tabsInstance.select('pasteTab');
                            }
                            
                            addImageToQueue(file, 'paste-global-shortcut'); // Use your existing function
                            logToConsole('Image pasted from clipboard via global shortcut.', 'info');
                            hasPastedImage = true;
                        }
                        break; // Process the first image found and stop
                    }
                }

                if (hasPastedImage) {
                    return; // If an image was successfully pasted, we're done.
                }

                // 3. If no image was pasted, check for a URL in text/plain data
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    if (item.type === 'text/plain') {
                        // item.getAsString() is asynchronous, so we need to handle its callback
                        // We wrap it in a Promise to use await for cleaner code
                        const text = await new Promise(resolve => item.getAsString(resolve));
                        
                        if (text) {
                            const trimmedText = text.trim();
                            // Basic URL validation: starts with http:// or https:// and is a valid URL structure
                            if ((trimmedText.startsWith('http://') || trimmedText.startsWith('https://'))) {
                                try {
                                    new URL(trimmedText); // This will throw an error if the URL is malformed

                                    event.preventDefault(); // Prevent default paste action

                                    // Switch to the "From URL" tab
                                    if (tabsInstance) {
                                        tabsInstance.select('urlTab');
                                    }

                                    imageUrlInput.value = trimmedText;
                                    
                                    // Ensure the Materialize label for the URL input updates correctly
                                    const labelForUrlInput = document.querySelector('label[for="imageUrlInput"]');
                                    if (labelForUrlInput) {
                                        labelForUrlInput.classList.add('active');
                                    }
                                    // M.updateTextFields(); // If you were using this elsewhere, but direct label manipulation is fine

                                    logToConsole(`URL pasted into field via global shortcut: ${trimmedText.substring(0,50)}...`, 'info');
                                    
                                    // Optionally, focus the input field so the user can see it and press "Add"
                                    imageUrlInput.focus();

                                } catch (e) {
                                    // The text was not a valid URL, so do nothing with it here.
                                    // console.warn("Pasted text looked like a URL but was invalid:", trimmedText, e);
                                }
                            }
                        }
                        break; // Process the first text/plain item found and stop
                    }
                }
            });

            // --- Queue Processing Logic ---
            clearQueueButton.addEventListener('click', function() { 
                if (isProcessing) { logToConsole("Cannot clear queue while processing.", 'warning'); return; }
                if (imageQueue.length === 0) { logToConsole("Queue is already empty.", 'info'); return; }
                
                imageQueueAreaSidenav.querySelectorAll('.tooltipped').forEach(el => { const i = M.Tooltip.getInstance(el); if (i) i.destroy(); });
                imageQueue = []; imageQueueAreaSidenav.innerHTML = ''; 
                emptyQueueMessageSidenav.style.display = 'block'; updateQueueControls(); 
                logToConsole('Image queue cleared.', 'success');
            });

            processQueueButton.addEventListener('click', async function() { 
                if (isProcessing || isSingleItemProcessing || !settingsModalInstance.options.dismissible) {
                    if (!settingsModalInstance.options.dismissible) logToConsole("API not configured. Please set it in Settings.", "warning");
                    else if (isSingleItemProcessing) logToConsole("Cannot start queue: An item is currently being individually regenerated.", "warning");
                    return;
                }
                const toProcess = imageQueue.filter(it => it.status === 'Pending');
                if (!toProcess.length) { logToConsole('No pending images to process.', 'info'); return; }

                isProcessing = true;
                updateQueueControls(); 

                logToConsole(`Starting to process ${toProcess.length} image(s)...`, 'info');
                const currentPromptType = promptForm.elements['promptType'].value;
                const promptTxt = getPromptText();
                let totalQueueStartTime = performance.now();
                let processedCount = 0; let overallSuccess = true;

                for (let i = 0; i < toProcess.length; i++) {
                    const item = imageQueue.find(iq => iq.id === toProcess[i].id); // Get current reference
                    if (!item || item.status !== 'Pending') { continue; }

                    item.status = 'Processing'; 
                    processQueueButton.innerHTML = `Processing "${item.displayTitle.substring(0,15)}..." (${processedCount+1}/${toProcess.length}) <i class="material-icons right spin">autorenew</i>`;
                    updateQueueItemUI(item);
                    
                    const itemStartTime = performance.now();
                    const payload = { model: currentSelectedModel, messages: [{ role: "system", content: "You are a helpful image captioner." },{ role: "user", content: [{ type: "text", text: promptTxt },{ type: "image_url", image_url: { url: item.base64Image } }] }], temperature: 0.6, max_tokens: 512, stream: true };
                    const fetchHeaders = { 'Content-Type': 'application/json' };
                    if (currentApiKey) fetchHeaders['Authorization'] = `Bearer ${currentApiKey}`;
                    
                    try {
                        const fullChatEndpointForProcessing = currentBaseUrl.replace(/\/$/, '') + currentChatPath;
                        const r = await fetch(fullChatEndpointForProcessing, { method: 'POST', headers: fetchHeaders, body: JSON.stringify(payload) });
                        if (!r.ok) { const ed = await r.json().catch(()=>({detail:`API Error ${r.status}`})); throw new Error(`${ed.detail || `HTTP ${r.status}`}`);}
                        if (!r.body) throw new Error("Response has no body (stream)."); 
                        const rd = r.body.getReader(); const dec = new TextDecoder();
                        let buf = ''; let fullTxt = '';
                        while (true) {
                            const { done, value } = await rd.read(); if (done) break;
                            buf += dec.decode(value, { stream: true }); let pos;
                            while ((pos = buf.indexOf('\n\n')) >= 0) {
                                const ln = buf.substring(0, pos).trim(); buf = buf.substring(pos + 2);
                                if (ln.startsWith('data: ')) {
                                    const jd = ln.substring(6); if (jd === '[DONE]') break;
                                    try { const p = JSON.parse(jd); if (p.choices?.[0]?.delta?.content) fullTxt += p.choices[0].delta.content; }
                                    catch (e) { console.warn("Stream JSON chunk parse error:", e, jd); }
                                }
                            } if (buf.includes('data: [DONE]')) break;
                        } 
                        item.output = filterApiResponse(fullTxt.trim(), currentPromptType);
                        item.status = 'Completed';
                        logToConsole(`Successfully processed "${item.displayTitle}".`, 'success', (performance.now() - itemStartTime) / 1000);
                        processedCount++;
                    } catch (e) { 
                        item.status = 'Error'; item.error = e.message; 
                        logToConsole(`Error processing "${item.displayTitle}": ${e.message.substring(0,150)}`, 'error', (performance.now() - itemStartTime) / 1000);
                        overallSuccess = false;
                    }

                    item.promptTypeUsed = currentPromptType;
                    updateQueueItemUI(item);
                    
                    if (i < toProcess.length - 1) await new Promise(res => setTimeout(res, 100));
                }

                isProcessing = false;
                updateQueueControls();
                imageQueue.forEach(it => updateQueueItemUI(it));

                if (toProcess.length > 0) {
                     logToConsole(`Queue processing finished! ${processedCount}/${toProcess.length} processed. ${overallSuccess ? '' : 'Some errors.'}`, overallSuccess ? 'success' : 'warning', (performance.now() - totalQueueStartTime) / 1000);
                }
            });

            document.getElementById('copyOptionsDropdown').addEventListener('click', function(event) {
                event.preventDefault(); // Prevent default link behavior
                const target = event.target.closest('a'); // Handle clicks on <a> or its children
                if (target && target.dataset.format) {
                    handleCopyExport(target.dataset.format);
                    // Optional: Close dropdown after click. Materialize might do this by default.
                    const instance = M.Dropdown.getInstance(copyAllOutputsButton);
                    if (instance) instance.close();
                }
            });

            document.getElementById('downloadOptionsDropdown').addEventListener('click', function(event) {
                event.preventDefault(); // Prevent default link behavior
                const target = event.target.closest('a');
                if (target && target.dataset.format) {
                    handleDownloadExport(target.dataset.format);
                    // Optional: Close dropdown
                    const instance = M.Dropdown.getInstance(downloadAllOutputsButton);
                    if (instance) instance.close();
                }
            });
            
            function copyToClipboard(text, message = 'Copied!') {
                navigator.clipboard.writeText(text).then(() => logToConsole(message, 'success'))
                .catch(err => {
                    console.error('Clipboard copy failed: ', err);
                    logToConsole('Failed to copy. Check browser permissions or console.', 'error');
                });
            }

            function getExportableItemsDetails() {
                return imageQueue
                    .filter(item => item.status === 'Completed' && item.output && typeof item.output === 'string' && item.output.trim() !== '')
                    .map((item, index) => ({ // The original index from filter is not used for 1-based display index
                        id: item.id, // Keep id if needed for other purposes
                        output: item.output.trim(),
                        displayTitle: item.displayTitle,
                        // Note: The 'index' in the object for formatOutputsJson will be 1-based.
                    }));
            }

            function getProcessedDelimiter() {
                if (typeof currentRawDelimiter !== 'string') return '\n\n'; // Fallback
                return currentRawDelimiter.replace(/\\n/g, '\n').replace(/\\t/g, '\t');
            }

            function formatOutputsRaw(outputs) {
                if (!outputs || outputs.length === 0) return "";
                const delimiter = getProcessedDelimiter();
                return outputs.join(delimiter);
            }

            function formatOutputsJson(detailedItems) { 
                if (!detailedItems || detailedItems.length === 0) {
                    let emptySchema = currentJsonSchema;
                    const currentGlobalPromptTypeForEmpty = promptForm.elements['promptType'].value;
                    emptySchema = emptySchema.replace(/"?\{\{prompt_type\}\}"?/g, JSON.stringify(currentGlobalPromptTypeForEmpty));
                    emptySchema = emptySchema.replace(/"?\{\{outputs_map_indexed\}\}"?/g, ''); 
                    emptySchema = emptySchema.replace(/"?\{\{outputs_map_titled\}\}"?/g, '');  
                    emptySchema = emptySchema.replace(/"?\{\{outputs_array_detailed\}\}"?/g, ''); 
                    emptySchema = emptySchema.replace(/"?\{\{timestamp\}\}"?/g, `"${new Date().toISOString()}"`);

                    emptySchema = emptySchema.replace(/,\s*([}\]])/g, '$1'); 
                    emptySchema = emptySchema.replace(/([{\[])\s*,/g, '$1'); 

                    try {
                        return JSON.stringify(JSON.parse(emptySchema), null, 2);
                    } catch (e) {
                        logToConsole(`Error parsing user JSON schema (even with empty data): ${e.message.substring(0,100)}. Schema: ${emptySchema.substring(0,100)}`, 'error');
                        return JSON.stringify({ "Prompts": {}, "error": "Schema parsing failed with no data" }, null, 2);
                    }
                }

                let schemaToProcess = currentJsonSchema;
                const currentGlobalPromptType = promptForm.elements['promptType'].value;

                if (schemaToProcess.includes('{{outputs_map_indexed}}')) {
                    const mapIndexedItems = detailedItems.map((item, index) => {
                        const key = JSON.stringify(String(index + 1)); 
                        const value = JSON.stringify(String(item.output));   
                        return `${key}: ${value}`;
                    });
                    const mapIndexedString = mapIndexedItems.join(',\n            '); 
                    schemaToProcess = schemaToProcess.replace(/"?\{\{outputs_map_indexed\}\}"?/g, mapIndexedString);
                }

                if (schemaToProcess.includes('{{outputs_map_titled}}')) {
                    const mapTitledItems = detailedItems.map(item => {
                        const key = JSON.stringify(String(item.displayTitle));
                        const value = JSON.stringify(String(item.output));
                        return `${key}: ${value}`;
                    });
                    const mapTitledString = mapTitledItems.join(',\n            ');
                    schemaToProcess = schemaToProcess.replace(/"?\{\{outputs_map_titled\}\}"?/g, mapTitledString);
                }

                if (schemaToProcess.includes('{{outputs_array_detailed}}')) {
                    const arrayDetailedItems = detailedItems.map((item, index) => {
                        const detail = {
                            index: index + 1,
                            output: String(item.output),
                            displayTitle: String(item.displayTitle),
                            promptTypeUsed: item.promptTypeUsed || currentGlobalPromptType // Add promptTypeUsed to detailed item
                        };
                        return JSON.stringify(detail); 
                    });
                    const arrayDetailedString = arrayDetailedItems.join(',\n            ');
                    schemaToProcess = schemaToProcess.replace(/"?\{\{outputs_array_detailed\}\}"?/g, arrayDetailedString);
                }
                
                schemaToProcess = schemaToProcess.replace(/"?\{\{timestamp\}\}"?/g, `"${new Date().toISOString()}"`);
                schemaToProcess = schemaToProcess.replace(/"?\{\{prompt_type\}\}"?/g, JSON.stringify(currentGlobalPromptType));


                schemaToProcess = schemaToProcess.replace(/,\s*([}\]])/g, '$1'); 
                schemaToProcess = schemaToProcess.replace(/([{\[])\s*,/g, '$1'); 

                try {
                    const finalJson = JSON.parse(schemaToProcess);
                    return JSON.stringify(finalJson, null, 2);
                } catch (e) {
                    logToConsole(`Error parsing user-defined JSON schema after replacements: ${e.message.substring(0,150)}. Schema was: ${schemaToProcess.substring(0, 250)}...`, 'error');
                    const fallbackArray = detailedItems.map((item, index) => ({
                        index: index + 1,
                        output: item.output,
                        displayTitle: item.displayTitle,
                        promptTypeUsed: item.promptTypeUsed || currentGlobalPromptType,
                        error_details: "User-defined JSON schema failed to parse. See console log for attempted schema."
                    }));
                    return JSON.stringify(fallbackArray, null, 2);
                }
            }

            function handleCopyExport(format) {
                const exportableItems = getExportableItemsDetails();
                if (exportableItems.length === 0) {
                    logToConsole('No completed prompts available to copy.', 'warning');
                    M.toast({html: 'No completed prompts to copy!'});
                    return;
                }

                let contentToCopy;
                let typeForLog;

                if (format === 'raw') {
                    // formatOutputsRaw expects an array of strings (the outputs themselves)
                    const rawOutputsOnly = exportableItems.map(item => item.output);
                    contentToCopy = formatOutputsRaw(rawOutputsOnly);
                    typeForLog = "RAW text";
                } else if (format === 'json') {
                    // formatOutputsJson expects the array of detailed items
                    contentToCopy = formatOutputsJson(exportableItems);
                    typeForLog = "JSON";
                } else {
                    logToConsole(`Invalid export format for copy: ${format}`, 'error');
                    return;
                }

                if (contentToCopy) {
                    copyToClipboard(contentToCopy, `${exportableItems.length} prompt(s) copied as ${typeForLog}.`);
                } else {
                    // This case should ideally not be hit if outputs.length > 0
                    logToConsole(`No content generated for ${typeForLog} copy.`, 'warning');
                    M.toast({html: 'Nothing to copy!'});
                }
            }

            function handleDownloadExport(format) {
                const exportableItems = getExportableItemsDetails();
                if (exportableItems.length === 0) {
                    logToConsole('No completed prompts available to download.', 'warning');
                    M.toast({html: 'No completed prompts to download!'});
                    return;
                }

                let fileContent;
                let fileName;
                let mimeType;
                let typeForLog;

                const date = new Date();
                const timestamp = `${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}_${date.getHours().toString().padStart(2,'0')}${date.getMinutes().toString().padStart(2,'0')}${date.getSeconds().toString().padStart(2,'0')}`;
                
                const currentGlobalPromptType = promptForm.elements['promptType'].value;
                const formattedPromptType = currentGlobalPromptType.replace(/[^a-z0-9_.-]/gi, '_').toLowerCase();


                if (format === 'raw') {
                    const rawOutputsOnly = exportableItems.map(item => item.output);
                    fileContent = formatOutputsRaw(rawOutputsOnly);
                    fileName = `BiCaption_exports_${formattedPromptType}_${timestamp}.txt`;
                    mimeType = 'text/plain;charset=utf-8';
                    typeForLog = "RAW text";
                } else if (format === 'json') {
                    fileContent = formatOutputsJson(exportableItems);
                    fileName = `BiCaption_exports_${formattedPromptType}_${timestamp}.json`;
                    mimeType = 'application/json;charset=utf-8';
                    typeForLog = "JSON";
                } else {
                    logToConsole(`Invalid export format for download: ${format}`, 'error');
                    return;
                }

                if (fileContent) {
                    const blob = new Blob([fileContent], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a); 
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    logToConsole(`${exportableItems.length} prompt(s) downloaded as ${typeForLog} to ${fileName}.`, 'success');
                } else {
                    logToConsole(`No content generated for ${typeForLog} download.`, 'warning');
                    M.toast({html: 'Nothing to download!'});
                }
            }

            // Final UI update after all setup
            updateQueueControls(); 
        });
    </script>
</body>
</html>